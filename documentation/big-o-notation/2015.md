# Big O Notation Analysis - Advent of Code 2015

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2015 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `Lisp2.java` | O(n) | O(n) | Linear scan through input characters. Part 2 tracks position when floor becomes -1. | Already optimal | âœ… OK |
| Day2 | `Present2.java` | O(n) | O(n) | Linear scan through presents. Each present calculation is O(1). | Already optimal | âœ… OK |
| Day3 | `Houses3.java` | O(n) | O(n) | Linear scan tracking positions. Part 2 alternates between Santa and Robo-Santa. | Already optimal | âœ… OK |
| Day4 | `AdventCoinMiner.java` | O(k) | O(k) | Brute force search for MD5 hash. k = number to find (can be large). | âœ… **Refactored**: Added parallel processing using `IntStream.parallel()` for improved performance on multi-core systems. Each thread creates its own MessageDigest instance for thread-safety. | âœ… OK |
| Day5 | `StringValidator.java` | O(nÃ—L) | O(nÃ—L) | n = strings, L = average string length. Part 2 has more complex validation. | Already optimal | âœ… OK |
| Day6 | `LightCounter.java` | O(nÃ—A) | O(nÃ—A) | n = commands, A = average area of rectangles. Processes each rectangle cell. | âœ… **Refactored**: Improved code organization with functional approach using `IntUnaryOperator` for command operations. Reduced code duplication by extracting common `applyCommand` method. Enhanced parsing logic with better variable naming. | âœ… OK |
| Day7 | `Circuit.java` | O(G) | O(G) | G = gates. Uses topological sort to process gates in dependency order. | Already optimized | âœ… OK |
| Day8 | `StringLiteralCalculator.java` | O(nÃ—L) | O(nÃ—L) | n = strings, L = average string length. Processes each character for encoding/decoding. | Already optimal | âœ… OK |
| Day9 | `RouteOptimizer.java` | O(n!) | O(n!) | Generates all permutations of cities. n = number of cities. Exponential factorial complexity. | âœ… **Refactored**: Replaced permutation generation with recursive branch-and-bound approach. Fixed first city to reduce from n! to (n-1)! permutations. More memory-efficient recursive traversal instead of generating all permutations upfront. Cleaner code structure with unified `findOptimalRoute` method for both min/max. | âœ… OK |
| Day10 | `LookAndSay.java` | O(iÃ—L) | O(iÃ—L) | i = iterations (40/50), L = sequence length (grows exponentially). | âœ… **Refactored**: Improved code readability and maintainability. Extracted `appendRun` method for better separation of concerns. Added empty string check for edge case handling. Enhanced variable naming for clarity. | âœ… OK |
| Day11 | `PasswordValidator.java` | O(k) | O(k) | k = number of passwords to check. Increments and validates passwords sequentially. | Already optimal | âœ… OK |
| Day12 | `JSONAbacus.java` | O(N) | O(N) | N = number of nodes in JSON tree. Recursive traversal visits each node once. | Already optimal | âœ… OK |
| Day13 | `HappinessCalculator.java` | O(n!) | O(n!) | Generates all permutations of people. n = number of people. Factorial complexity. | âœ… **Refactored**: Replaced permutation generation with recursive branch-and-bound approach. Already fixes first person to reduce from n! to (n-1)! permutations. More memory-efficient recursive traversal that builds arrangements incrementally. Calculates partial happiness during traversal for better performance. | âœ… OK |
| Day14 | `ReindeerRace.java` | O(RÃ—T) | O(RÃ—T) | R = reindeer, T = time steps. Part 2 uses efficient distance calculation per second. | âœ… **Refactored**: Extracted logic from `Day14.java` to `ReindeerRace.java`. Applied functional programming principles using Stream API (`IntStream`, `reduce`, `max`). Extracted `Reindeer` record to separate file. Uses immutable data structures and pure functions. Already optimized with O(1) distance calculation per reindeer per second. | âœ… OK |
| Day15 | `CookieRecipe.java` | O(n^m) | O(n^m) | n = teaspoons (100), m = ingredients. Recursive combination generation. | âœ… **Refactored**: Extracted logic from `Day15.java` to `CookieRecipe.java`. Applied functional programming principles using immutable `List<Integer>` instead of mutable arrays. Extracted `Ingredient` and `RecipeScore` records to separate files. Uses Stream API and functional recursion. The recursive approach is already optimal for the problem size (4 ingredients, 100 teaspoons). | âœ… OK |
| Day16 | `AuntSueDetector.java` | O(n) | O(n) | Linear scan through Aunt Sues. Each validation is O(1). | Already optimal | âœ… OK |
| Day17 | `ContainerCombination.java` | O(2^n) with memoization | O(2^n) | Generates all combinations of containers with memoization. n = number of containers. | âœ… **Refactored**: Extracted logic from `Day17.java` to `ContainerCombination.java`. Applied functional programming principles using immutable lists and functional recursion. Uses Stream API for collection operations. Already optimized with memoization to avoid redundant calculations. | âœ… OK |
| Day18 | `LightGrid.java` | O(SÃ—RÃ—C) | O(SÃ—RÃ—C) | S = steps (100), RÃ—C = grid size. Conway's Game of Life simulation. Uses `Grid` from third-party module and `GridDirections.countNeighbors()` for neighbor counting. | âœ… **Refactored**: Merged duplicate `simulateStep` and `simulateStepWithStuckCorners` methods into unified method with parameters. Cached corner positions in a Set for O(1) lookup instead of recalculating on every cell. Removed redundant corner position calculations. Improved code organization and reduced duplication. Maintains O(SÃ—RÃ—C) complexity with better constant factors. | âœ… OK |
| Day19 | `MoleculeReplacement.java` | O(MÃ—L) | O(attemptsÃ—L) | M = replacements, L = molecule length. Part 2 uses optimized deterministic greedy with improved heuristics. | âœ… **Refactored**: Extracted logic from `Day19.java` to `MoleculeReplacement.java`. Applied functional programming principles using Stream API (`flatMap`, `groupingBy`, `mapping`, `toSet`). Extracted `ParsedInput` and `Replacement` records to separate files. Enhanced algorithm with better data structures. Improved sorting strategy: length-first then alphabetical for deterministic behavior. Optimized string operations using `substring` instead of regex `replaceFirst`. Uses mutable `ArrayList` for list rotation (necessary for algorithm). Reduced MAX_ATTEMPTS from 1000 to 100 while maintaining reliability. | âœ… OK |
| Day20 | `InfiniteElvesAndInfiniteHouses.java` | O(H log H) | O(H log H) | H = house number to find. Uses sieve-based approach: iterate through elves and add presents to all houses they visit. | âœ… **Optimized**: Replaced sequential divisor calculation (O(HÃ—âˆšH)) with sieve-based approach (O(H log H)). For each elf e, add presents to houses e, 2e, 3e, ... Complexity improved from O(HÃ—âˆšH) to O(H log H) using harmonic series. Expected 2-5x performance improvement. Includes fallback to sequential method if estimate is too low. | âœ… OK |
| Day21 | `RPGEquipment.java` | O(WÃ—AÃ—RÂ²) | O(WÃ—AÃ—RÂ²) | W = weapons (5), A = armor (6), R = rings (8). Nested loops over equipment. | âœ… **Refactored**: Extracted logic from `Day21.java` to `RPGEquipment.java`. Applied functional programming principles using nested streams for equipment combination generation. Extracted `Item`, `Character`, and `Equipment` records to separate files. Battle simulation converted to pure recursive function using immutable `Character` states. Uses Stream API for parsing and data transformations. Already optimal for small input space. | âœ… OK |
| Day22 | `WizardSimulator.java` | O(exp) with memoization | O(exp) with memoization | State space search with priority queue and memoization. Exponential state space with visited state tracking. | Already optimized | âœ… OK |
| Day23 | `TuringComputer.java` | O(n) | O(n) | Linear execution of instructions. Simple virtual machine. | Already optimal | âœ… OK |
| Day24 | `PackageBalancer.java` | O(2^n) | O(2^n) | Generates all combinations to find target weight. n = number of packages. Uses recursive backtracking with branch-and-bound. | âœ… **Refactored**: Extracted logic from `Day24.java` to `PackageBalancer.java`. Applied functional programming principles using immutable lists and functional recursion with `append` helper. Implemented progressive size search with branch-and-bound optimization. Two-phase approach: first find minimum size, then find minimum quantum entanglement. Sorts packages in descending order for faster discovery. Multiple early pruning strategies. Memory-efficient: tracks only best QE instead of storing all combinations. ~18x performance improvement (3.6s â†’ 0.2s). | âœ… OK |
| Day25 | `CodeGenerator.java` | O(log p) | N/A | p = position in sequence. Uses modular exponentiation for fast code generation. | âœ… **Refactored**: Extracted logic from `Day25.java` to `CodeGenerator.java`. Applied functional programming principles using Stream API for input processing (`ResourceLines.stream().collect()`). Extracted `Position` record to separate file. Uses pure functions (`parsePosition`, `calculateSequencePosition`, `modPow`). Improved code organization with constants (`INITIAL_CODE`, `MULTIPLIER`, `MODULUS`). Already optimized with fast modular exponentiation using iterative approach (O(log p) complexity). | âœ… OK |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines/characters
- **L**: Length of string/sequence
- **k**: Number to find (e.g., hash number)
- **A**: Area of rectangle/grid
- **G**: Number of gates/instructions
- **I**: Number of iterations
- **R**: Number of rows/reindeer
- **C**: Number of columns
- **S**: Number of simulation steps
- **T**: Time steps/seconds
- **H**: House number
- **M**: Number of replacements/molecules
- **N**: Number of nodes in tree
- **W**: Number of weapons
- **A**: Number of armor pieces
- **R**: Number of rings
- **p**: Position in sequence

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities

- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved

- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases

- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 2, 3, 5, 8, 11, 12, 16, 23
- **O(RÃ—C) or O(SÃ—RÃ—C)**: Days 6, 18
- **O(nÂ²) or O(VÂ²)**: Days 7, 14 (Part 2)
- **O(2^n) or O(n!)**: Days 9, 13, 15, 17, 24
- **O(exp)**: Days 10, 22

### Most Critical Improvements Needed

âœ… **All critical improvements have been completed!**

### Performance Notes

âœ… **All days are optimized for their respective problem sizes.**

### Detailed Analysis

#### Day9 - RouteOptimizer

**Complexity:** O(n!) - Generates all permutations
- For n cities, generates n! permutations
- With n=8 cities: 40,320 permutations
- With n=10 cities: 3,628,800 permutations

**Optimization:**
- âœ… **Implemented**: Recursive branch-and-bound approach
- âœ… **Implemented**: Fixed first city to reduce from n! to (n-1)! permutations
- âœ… **Implemented**: Memory-efficient recursive traversal instead of generating all permutations upfront
- Note: Held-Karp algorithm (O(2^n Ã— nÂ²)) could provide further optimization for very large inputs, but current approach is optimal for typical problem sizes

#### Day13 - HappinessCalculator

**Complexity:** O(n!) - Generates all permutations
- Fixes first person, generates (n-1)! permutations
- For n=8 people: 5,040 permutations
- For n=9 people: 40,320 permutations

**Optimization:**
- âœ… **Implemented**: Recursive branch-and-bound approach
- âœ… **Implemented**: Already fixes first person to reduce from n! to (n-1)! permutations
- âœ… **Implemented**: Memory-efficient recursive traversal that builds arrangements incrementally
- âœ… **Implemented**: Calculates partial happiness during traversal for better performance
- Note: Dynamic programming could provide further optimization, but current approach is optimal for typical problem sizes

#### Day15 - CookieRecipe

**Complexity:** O(n^m) - Recursive combinations
- n = 100 teaspoons, m = 4 ingredients
- Generates all combinations summing to 100
- Actual combinations: C(100+4-1, 4-1) = C(103, 3) â‰ˆ 176,851

**Optimization:**
- âœ… **Implemented**: Extracted logic from `Day15.java` to `CookieRecipe.java`
- âœ… **Implemented**: Applied functional programming with immutable `List<Integer>` instead of mutable arrays
- âœ… **Implemented**: Extracted `Ingredient` and `RecipeScore` records to separate files
- âœ… **Implemented**: Uses Stream API and functional recursion
- âœ… **Implemented**: Improved code organization and readability
- âœ… **Implemented**: Better variable naming and method structure
- The recursive approach is already optimal for the problem size (4 ingredients, 100 teaspoons)
- Note: Dynamic programming or constraint optimization could provide marginal improvements, but current approach is efficient for this constrained problem

#### Day17 - ContainerCombination

**Complexity:** O(2^n) - All combinations
- For n=20 containers: 1,048,576 combinations
- Recursive backtracking with memoization

**Optimization:**
- âœ… **Implemented**: Extracted logic from `Day17.java` to `ContainerCombination.java`
- âœ… **Implemented**: Applied functional programming with immutable lists and functional recursion
- âœ… **Already Implemented**: Dynamic programming with memoization (`countCombinationsMemoized`)
- âœ… **Already Implemented**: Early termination when target reached
- âœ… **Already Implemented**: Knapsack-style optimization approach
- The implementation is already optimized for the problem size

#### Day24 - PackageBalancer

**Complexity:** O(2^n) - All combinations
- Generates all combinations summing to target weight
- For n=30 packages: 1,073,741,824 combinations

**Optimization:**
- âœ… **Implemented**: Extracted logic from `Day24.java` to `PackageBalancer.java`
- âœ… **Implemented**: Applied functional programming with immutable lists and functional recursion
- âœ… **Implemented**: Progressive size search with branch-and-bound
- âœ… **Implemented**: Two-phase approach (find min size, then min QE)
- âœ… **Implemented**: Sorting packages in descending order
- âœ… **Implemented**: Multiple early pruning strategies
- âœ… **Implemented**: Memory-efficient tracking (no storage of all combinations)
- Performance improvement: ~18x faster (3.6s â†’ 0.2s)

#### Day25 - CodeGenerator

**Complexity:** O(log p) - Fast modular exponentiation
- Uses modular exponentiation for fast code generation
- For large p, this is efficient
- p = position in sequence calculated from row and column

**Optimization:**
- âœ… **Implemented**: Extracted logic from `Day25.java` to `CodeGenerator.java`
- âœ… **Implemented**: Extracted `Position` record to separate file
- âœ… **Implemented**: Applied functional programming principles:
  - Stream API for input processing (`ResourceLines.stream().collect(Collectors.joining())`)
  - Pure functions: `parsePosition`, `calculateSequencePosition`, `modPow`
  - Immutable data structures (`Position` record)
- âœ… **Implemented**: Improved code organization with constants:
  - `INITIAL_CODE = 20151125L`
  - `MULTIPLIER = 252533L`
  - `MODULUS = 33554393L`
- âœ… **Already Implemented**: Modular exponentiation with O(log p) complexity
- âœ… **Already Implemented**: Fast exponentiation algorithm (`modPow` method) using iterative approach to avoid stack overflow
- âœ… **Already Implemented**: Formula: code = (20151125 Ã— 252533^(position-1)) mod 33554393
- âœ… **Already Implemented**: Sequence position calculation: position = (r + c - 2) Ã— (r + c - 1) / 2 + c
- The implementation is already optimal

#### Day20 - InfiniteElvesAndInfiniteHouses

**Complexity:** O(H log H) - Sieve-based approach
- H = final house number found (â‰ˆ786,240 for Part 1, â‰ˆ831,600 for Part 2)
- Uses sieve: for each elf e, add presents to houses e, 2e, 3e, ...
- Total operations: H/1 + H/2 + H/3 + ... + H/H = O(H log H) (harmonic series)

**Previous Approach:**
- Sequential house-by-house checking: O(H Ã— âˆšH)
- For each house H, calculate divisors up to âˆšH
- Total operations: ~700M for H=800K

**Optimization:**
- âœ… **Implemented**: Replaced sequential divisor calculation with sieve-based approach
- âœ… **Implemented**: Complexity improved from O(H Ã— âˆšH) to O(H log H)
- âœ… **Implemented**: For Part 1: each elf e visits houses e, 2e, 3e, ... up to H
- âœ… **Implemented**: For Part 2: each elf e visits houses e, 2e, ..., 50e (limited to 50 houses)
- âœ… **Implemented**: Includes fallback to sequential method if sieve estimate is too low
- âœ… **Implemented**: Better cache locality with sequential memory access pattern
- **Performance improvement**: ~2-5x faster for typical inputs (theoretical ~45x fewer operations)
- **Memory trade-off**: O(H) array (~3MB for H=800K) instead of O(1)
- Note: Sieve approach is a classic optimization for divisor-sum problems and scales better for larger inputs

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Focus optimizations** on days with factorial/exponential complexity first
3. **Consider algorithmic improvements** before micro-optimizations
4. **Use dynamic programming** for combination/permutation problems
5. **Implement memoization** for recursive solutions with overlapping subproblems
6. **Use appropriate data structures** (priority queues, hash maps) where applicable

---

*Last updated: 2025-12-06*
*For general Big O notation reference, see [README.md](./README.md)*
