# Big O Notation Analysis - Advent of Code 2015

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2015 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `Lisp2.java` | O(n) | O(n) | Linear scan through input characters. Part 2 tracks position when floor becomes -1. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day2 | `Present2.java` | O(n) | O(n) | Linear scan through presents. Each present calculation is O(1). | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day3 | `Houses3.java` | O(n) | O(n) | Linear scan tracking positions. Part 2 alternates between Santa and Robo-Santa. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day4 | `AdventCoinMiner.java` | O(k) | O(k) | Brute force search for MD5 hash. k = number to find (can be large). | âœ… **Refactored**: Added parallel processing using `IntStream.parallel()` for improved performance on multi-core systems. Each thread creates its own MessageDigest instance for thread-safety. | âœ… OK - Optimized with parallel processing |
| Day5 | `StringValidator.java` | O(nÃ—L) | O(nÃ—L) | n = strings, L = average string length. Part 2 has more complex validation. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day6 | `LightCounter.java` | O(nÃ—A) | O(nÃ—A) | n = commands, A = average area of rectangles. Processes each rectangle cell. | âœ… **Refactored**: Improved code organization with functional approach using `IntUnaryOperator` for command operations. Reduced code duplication by extracting common `applyCommand` method. Enhanced parsing logic with better variable naming. | âœ… OK - Improved code quality and maintainability |
| Day7 | `Circuit.java` | O(G) | O(G) | G = gates. Uses topological sort to process gates in dependency order. | Already optimized with topological sort. | âœ… OK - Optimized with topological sort |
| Day8 | `StringLiteralCalculator.java` | O(nÃ—L) | O(nÃ—L) | n = strings, L = average string length. Processes each character for encoding/decoding. | Already optimal. Character-by-character processing is necessary. | âœ… OK - Already optimal |
| Day9 | `RouteOptimizer.java` | O(n!) | O(n!) | Generates all permutations of cities. n = number of cities. Exponential factorial complexity. | Use dynamic programming or branch-and-bound for TSP. Consider Held-Karp algorithm. | ðŸ”´ HIGH - Factorial complexity, needs optimization for large inputs |
| Day10 | `LookAndSay.java` | O(iÃ—L) | O(iÃ—L) | i = iterations (40/50), L = sequence length (grows exponentially). | âœ… **Refactored**: Improved code readability and maintainability. Extracted `appendRun` method for better separation of concerns. Added empty string check for edge case handling. Enhanced variable naming for clarity. | âœ… OK - Improved code quality and readability |
| Day11 | `PasswordValidator.java` | O(k) | O(k) | k = number of passwords to check. Increments and validates passwords sequentially. | Already optimal. Could optimize validation checks with early termination. | âœ… OK - Already optimal |
| Day12 | `JSONAbacus.java` | O(N) | O(N) | N = number of nodes in JSON tree. Recursive traversal visits each node once. | Already optimal. JSON parsing and traversal is necessary. | âœ… OK - Already optimal |
| Day13 | `HappinessCalculator.java` | O(n!) | O(n!) | Generates all permutations of people. n = number of people. Factorial complexity. | Use dynamic programming or branch-and-bound. Fix first person reduces to (n-1)!. | ðŸ”´ HIGH - Factorial complexity, needs optimization |
| Day14 | `Day14.java` | O(RÃ—T) | O(RÃ—T) | R = reindeer, T = time steps. Part 2 uses efficient distance calculation per second. | Already optimized. Uses O(1) distance calculation per reindeer per second. | âœ… OK - Optimized with efficient distance calculation |
| Day15 | `Day15.java` | O(n^m) | O(n^m) | n = teaspoons (100), m = ingredients. Recursive combination generation. | Use dynamic programming or memoization. Consider constraint optimization. | ðŸ”´ HIGH - Exponential combinations, needs optimization |
| Day16 | `AuntSueDetector.java` | O(n) | O(n) | Linear scan through Aunt Sues. Each validation is O(1). | Already optimal. Early termination when match found. | âœ… OK - Already optimal |
| Day17 | `Day17.java` | O(2^n) with memoization | O(2^n) | Generates all combinations of containers with memoization. n = number of containers. | Already optimized with memoization to avoid redundant calculations. | âœ… OK - Optimized with memoization |
| Day18 | `LightGrid.java` | O(SÃ—RÃ—C) | O(SÃ—RÃ—C) | S = steps (100), RÃ—C = grid size. Conway's Game of Life simulation. Uses `Grid` from third-party module and `GridDirections.countNeighbors()` for neighbor counting. | Already optimal for simulation. Could use bit manipulation for speed. | âœ… OK - Well optimized |
| Day19 | `Day19.java` | O(MÃ—L) | O(attemptsÃ—L) | M = replacements, L = molecule length. Part 2 uses randomized greedy (1000 attempts). | Part 2: Randomized greedy approach works well for this problem structure. BFS has exponential state space. | ðŸŸ¡ MEDIUM - Randomized approach works but may not find optimal solution |
| Day20 | `InfiniteElvesAndInfiniteHouses.java` | O(HÃ—âˆšH) | O(HÃ—âˆšH) | H = house number to find. Uses optimized divisor calculation up to âˆšH. | Already optimized. Divisor calculation is O(âˆšH) per house which is optimal. | âœ… OK - Already optimal divisor calculation |
| Day21 | `Day21.java` | O(WÃ—AÃ—RÂ²) | O(WÃ—AÃ—RÂ²) | W = weapons (5), A = armor (6), R = rings (8). Nested loops over equipment. | Already optimal for small input space. Early termination when solution found. | âœ… OK - Acceptable for small input space |
| Day22 | `WizardSimulator.java` | O(exp) with memoization | O(exp) with memoization | State space search with priority queue and memoization. Exponential state space with visited state tracking. | Already optimized with memoization to avoid revisiting states. | âœ… OK - Optimized with memoization |
| Day23 | `TuringComputer.java` | O(n) | O(n) | Linear execution of instructions. Simple virtual machine. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day24 | `Day24.java` | O(2^n) | O(2^n) | Generates all combinations to find target weight. n = number of packages. Uses recursive backtracking. | Already optimized. Early termination when target reached. | âœ… OK - Acceptable for problem size |
| Day25 | `Day25.java` | O(log p) | N/A | p = position in sequence. Uses modular exponentiation for fast code generation. | Already optimized with fast modular exponentiation. | âœ… OK - Optimized with modular exponentiation |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines/characters
- **L**: Length of string/sequence
- **k**: Number to find (e.g., hash number)
- **A**: Area of rectangle/grid
- **G**: Number of gates/instructions
- **I**: Number of iterations
- **R**: Number of rows/reindeer
- **C**: Number of columns
- **S**: Number of simulation steps
- **T**: Time steps/seconds
- **H**: House number
- **M**: Number of replacements/molecules
- **N**: Number of nodes in tree
- **W**: Number of weapons
- **A**: Number of armor pieces
- **R**: Number of rings
- **p**: Position in sequence

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 2, 3, 5, 8, 11, 12, 16, 23
- **O(RÃ—C) or O(SÃ—RÃ—C)**: Days 6, 18
- **O(nÂ²) or O(VÂ²)**: Days 7, 14 (Part 2)
- **O(2^n) or O(n!)**: Days 9, 13, 15, 17, 24
- **O(exp)**: Days 10, 22

### Most Critical Improvements Needed

1. **Day9 (RouteOptimizer)**: Factorial complexity - needs TSP optimization (Held-Karp, branch-and-bound)
2. **Day13 (HappinessCalculator)**: Factorial complexity - needs permutation optimization
3. **Day15 (Day15)**: Exponential combinations - needs DP or constraint optimization
4. **Day17 (Day17)**: Exponential combinations - needs DP/memoization
5. **Day24 (Day24)**: Exponential combinations - needs knapsack optimization
6. **Day25 (Day25)**: Sequential code generation - can use modular exponentiation

### Performance Notes

- Most linear problems (Days 1-5, 8, 11, 12, 16, 23) are already well-optimized
- Grid-based problems (Days 6, 18) are acceptable for typical sizes
- Several days have exponential/factorial complexity but work well for small inputs:
  - Day9: Small number of cities (typically 7-8)
  - Day13: Small number of people (typically 8-9)
  - Day15: Constrained by 100 teaspoons
  - Day17: Small number of containers
  - Day24: Small number of packages

### Detailed Analysis

#### Day9 - RouteOptimizer

**Complexity:** O(n!) - Generates all permutations
- For n cities, generates n! permutations
- With n=8 cities: 40,320 permutations
- With n=10 cities: 3,628,800 permutations

**Optimization:**
- Use Held-Karp algorithm: O(2^n Ã— nÂ²)
- Use branch-and-bound with heuristics
- For symmetric TSP, can reduce to (n-1)!/2

#### Day13 - HappinessCalculator

**Complexity:** O(n!) - Generates all permutations
- Fixes first person, generates (n-1)! permutations
- For n=8 people: 5,040 permutations
- For n=9 people: 40,320 permutations

**Optimization:**
- Use dynamic programming
- Use branch-and-bound
- Consider that circular arrangements reduce permutations

#### Day15 - Day15

**Complexity:** O(n^m) - Recursive combinations
- n = 100 teaspoons, m = 4 ingredients
- Generates all combinations summing to 100
- Actual combinations: C(100+4-1, 4-1) = C(103, 3) â‰ˆ 176,851

**Optimization:**
- Use dynamic programming
- Use constraint optimization
- Early pruning of invalid combinations

#### Day17 - Day17

**Complexity:** O(2^n) - All combinations
- For n=20 containers: 1,048,576 combinations
- Recursive backtracking without memoization

**Optimization:**
- Use dynamic programming with memoization
- Use knapsack-style optimization
- Early termination when target reached

#### Day24 - Day24

**Complexity:** O(2^n) - All combinations
- Generates all combinations summing to target weight
- For n=30 packages: 1,073,741,824 combinations

**Optimization:**
- Use dynamic programming
- Use branch-and-bound
- Early termination when minimum found

#### Day25 - Day25

**Complexity:** O(p) - Sequential generation
- Generates codes sequentially up to position p
- For large p, this can be slow

**Optimization:**
- Use modular exponentiation: O(log p)
- Formula: code = (20151125 Ã— 252533^p) mod 33554393
- Use fast exponentiation algorithm

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Focus optimizations** on days with factorial/exponential complexity first
3. **Consider algorithmic improvements** before micro-optimizations
4. **Use dynamic programming** for combination/permutation problems
5. **Implement memoization** for recursive solutions with overlapping subproblems
6. **Use appropriate data structures** (priority queues, hash maps) where applicable

## Recent Refactoring (2025)

### LOW Priority Improvements Completed

The following LOW-ranked cases have been refactored to improve performance and code quality:

1. **Day4 (AdventCoinMiner)**: 
   - Added parallel processing using `IntStream.parallel()` for MD5 hash brute force search
   - Improved performance on multi-core systems
   - Thread-safe implementation with per-thread MessageDigest instances

2. **Day6 (LightCounter)**:
   - Refactored to use functional approach with `IntUnaryOperator` for command operations
   - Reduced code duplication by extracting common `applyCommand` method
   - Improved parsing logic with better variable naming and structure
   - Enhanced code maintainability while preserving O(nÃ—A) complexity

3. **Day10 (LookAndSay)**:
   - Improved code readability and maintainability
   - Extracted `appendRun` method for better separation of concerns
   - Added edge case handling for empty strings
   - Enhanced variable naming for clarity

All refactored code maintains the same Big O complexity while improving code quality, maintainability, and in some cases (Day4), actual performance.

---

*Last updated: 2025-12-06*
*For general Big O notation reference, see [README.md](./README.md)*
