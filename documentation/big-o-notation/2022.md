# Big O Notation Analysis - Advent of Code 2022

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2022 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `Day1.java` | O(n log n) | O(n log n) | n = groups. Sorts groups by sum, then takes top k. | Already optimal. Sorting is necessary. | âœ… OK - Already optimal |
| Day2 | `Day2.java` | O(n) | O(n) | n = rounds. Processes each round with O(1) operations. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day3 | `Day3.java` | O(nÃ—L) | O(nÃ—L) | n = rucksacks, L = string length. Part 2 groups by 3. | Already optimal. Set intersection is necessary. | âœ… OK - Already optimal |
| Day4 | `Day4.java` | O(nÃ—R) | O(nÃ—R) | n = pairs, R = range size. Creates lists for ranges. | Could optimize by checking ranges without creating lists. | ðŸŸ¡ MEDIUM - Creates full range lists unnecessarily |
| Day5 | `Day5.java` | O(nÃ—m) | O(nÃ—m) | n = commands, m = quantity per command. Stack operations. | Already optimal. Stack operations are necessary. | âœ… OK - Already optimal |
| Day6 | `Day6.java` | O(nÃ—L) | O(nÃ—L) | n = lines, L = line length. Checks each position for unique characters. | Already optimal. Sliding window is necessary. | âœ… OK - Already optimal |
| Day7 | `Day7.java` | O(n) | O(n) | n = commands. Processes file system linearly. | Already optimal. Stack-based traversal is efficient. | âœ… OK - Already optimal |
| Day8 | `Day8.java` | O(RÃ—CÃ—max(R,C)) | O(RÃ—CÃ—max(R,C)) | RÃ—C = grid size. For each cell, checks visibility in 4 directions. Uses `Grid` from third-party module and `GridDirections.scanDirection()` for directional scanning. | Could optimize by precomputing visibility from edges. | ðŸŸ¡ MEDIUM - Can optimize with dynamic programming |
| Day9 | `Day9.java` | O(nÃ—s) | N/A | n = movements, s = steps per movement. Uses `Grid` from third-party module for visited cell tracking. Part 2 not implemented. | Part 2 needs implementation. | ðŸ”´ HIGH - Part 2 not implemented |
| Day10 | `Day10.java` | O(n) | O(n) | n = instructions. Processes instructions linearly. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day11 | N/A | N/A | N/A | Day 11 not found in module. | N/A | ðŸ”´ HIGH - Day 11 not implemented |
| Day12 | N/A | N/A | N/A | Day 12 not found in module. | N/A | ðŸ”´ HIGH - Day 12 not implemented |
| Day13 | `Day13.java` | O(nÃ—L) | O(nÃ—L log n) | n = packet pairs, L = packet length. Part 2 sorts all packets. | Already optimal. Recursive comparison is necessary. | âœ… OK - Already optimal |
| Day14 | N/A | N/A | N/A | Day 14 not found in module. | N/A | ðŸ”´ HIGH - Day 14 not implemented |
| Day15 | `Day15.java` | O(nÃ—W) | O(maxÃ—nÃ—R) | n = sensors, W = width, max = 4000000, R = ranges per row. Part 2 brute force checks each row. | Part 2: Can optimize with range merging and early termination. | ðŸŸ¡ MEDIUM - Part 2 brute force can be optimized |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines/commands/packets/sensors
- **L**: Length of string/sequence/packet
- **R**: Range size or number of rows
- **C**: Number of columns
- **W**: Width of search area
- **s**: Number of steps per movement
- **m**: Quantity per command
- **max**: Maximum coordinate value (e.g., 4000000)

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Missing day implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 2, 3, 5, 7, 10, 13
- **O(nÃ—L)**: Days 3, 6, 13
- **O(nÃ—R)**: Day 4
- **O(nÃ—m)**: Day 5
- **O(RÃ—CÃ—max(R,C))**: Day 8
- **O(nÃ—s)**: Day 9
- **O(nÃ—W) or O(maxÃ—nÃ—R)**: Day 15

### Most Critical Improvements Needed

1. **Day9 (Day9)**: Part 2 not implemented
   - Needs implementation for rope with 10 knots
   - Similar to Part 1 but tracks multiple knot positions

2. **Day15 (Day15)**: Part 2 brute force
   - Checks each row from 0 to 4000000
   - Can optimize with range merging and early termination
   - Could use mathematical approach to find gaps

3. **Day4 (Day4)**: Creates full range lists
   - Creates lists for entire ranges (e.g., 1-100 creates 100 elements)
   - Can optimize by checking range boundaries directly

4. **Day8 (Day8)**: Checks visibility for each cell
   - For each cell, checks visibility in 4 directions
   - Can optimize with dynamic programming from edges

### Missing Days

- **Day 11**: Not implemented
- **Day 12**: Not implemented
- **Day 14**: Not implemented

### Performance Notes

- Most linear problems (Days 1-3, 5, 7, 10, 13) are already well-optimized
- Day1 uses sorting which is optimal for finding top k elements
- Day7 uses stack-based file system traversal which is efficient
- Day13 uses recursive packet comparison which is necessary
- Day15 Part 2 has O(maxÃ—nÃ—R) complexity which can be slow for large inputs

### Detailed Analysis

#### Day4 - Day4

**Complexity:** O(nÃ—R) - Creates lists for ranges
- For each pair, creates lists for both ranges
- Range size R can be large (e.g., 1-100 creates 100 elements)
- Uses `containsAll` which is O(R) for each check

**Optimization:**
- Check range boundaries directly without creating lists
- For subset check: `range1.start <= range2.start && range1.end >= range2.end`
- For overlap check: `range1.start <= range2.end && range2.start <= range1.end`
- Reduces complexity to O(n)

#### Day8 - Day8

**Complexity:** O(RÃ—CÃ—max(R,C)) - Checks visibility for each cell
- For each cell (RÃ—C), checks visibility in 4 directions using `GridDirections.scanDirection()`
- Each direction check can scan up to max(R,C) cells
- Total: O(RÃ—CÃ—max(R,C))
- Uses `Grid` from third-party module and `GridDirections.scanDirection()` for directional scanning

**Optimization:**
- Precompute visibility from each edge using dynamic programming
- From left: `visible[i][j] = max(visible[i][j-1], grid[i][j])`
- Similar for right, top, bottom
- Reduces to O(RÃ—C) for visibility check
- Scenic score still requires O(RÃ—CÃ—max(R,C)) but can be optimized with early termination
- `GridDirections.scanDirection()` provides standardized directional scanning functionality

#### Day9 - Day9

**Complexity:** O(nÃ—s) - Processes movements step by step
- n = number of movements
- s = steps per movement
- Part 2 not implemented

**Optimization:**
- Part 2 needs implementation
- Similar to Part 1 but tracks 10 knot positions
- Can use same approach with array of positions

#### Day15 - Day15

**Complexity:**
- Part 1: O(nÃ—W) - Checks each position in width W
- Part 2: O(maxÃ—nÃ—R) - Checks each row, processes ranges

**Optimization:**
- Part 1: Already reasonable for typical inputs
- Part 2: Can optimize with:
  - Range merging per row: O(n log n) per row
  - Early termination when gap found
  - Mathematical approach: find gaps in merged ranges
  - Reduces to O(maxÃ—n log n) worst case, but typically much better with early termination

## Recommendations

1. **Implement missing days**: Days 9 (Part 2), 11, 12, 14
2. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
3. **Focus optimizations** on:
   - Day4: Remove range list creation
   - Day8: Use dynamic programming for visibility
   - Day15: Optimize Part 2 with range merging and early termination
4. **Consider algorithmic improvements** before micro-optimizations
5. **Use appropriate data structures** (ranges, intervals) where applicable
6. **Early termination** in loops where possible (Day15 Part 2)

---

*Last updated: 2025*
*For general Big O notation reference, see [README.md](./README.md)*
