# Big O Notation Analysis - Advent of Code 2023

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2023 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day3 | `Day3.java` | O(RÃ—CÃ—L) | O(RÃ—CÃ—L) | RÃ—C = grid size, L = average number length. Scans grid for symbols, then checks adjacent cells for numbers. Uses `Grid` from third-party module. | Could optimize by preprocessing number positions. Early termination when symbol has no adjacent digits. | âœ… OK - Already optimal |

## Legend

### Variable Definitions

- **R**: Number of rows in grid
- **C**: Number of columns in grid
- **L**: Average length of numbers in grid

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(RÃ—CÃ—L)**: Day 3

### Performance Notes

- Day 3 processes a grid to find symbols and extract adjacent numbers
- Uses `Grid` from third-party module for efficient grid operations
- Each symbol is checked for adjacent digits, and numbers are extracted once per symbol
- Complexity is optimal as we must examine each grid cell and process adjacent numbers

### Detailed Analysis

#### Day3 - Day3

**Part 1 Analysis:**
- Reads input and creates grid: O(RÃ—C) using `GridUtils.of()`
- Finds all symbols: O(RÃ—C) - scans entire grid
- For each symbol (S symbols):
  - Checks 8 adjacent cells: O(1)
  - Extracts numbers from adjacent cells: O(L) per number
  - Each number is extracted once per symbol that touches it
- **Overall: O(RÃ—CÃ—L)** where L is average number length

**Part 2 Analysis:**
- Same structure as Part 1
- Filters symbols to only gears ('*')
- Counts adjacent numbers (must be exactly 2)
- Multiplies gear ratios
- **Overall: O(RÃ—CÃ—L)** - same complexity as Part 1

**Algorithm Notes:**
- Uses `Grid` from `com.putoet.grid` for efficient grid operations
- `findNumber()` extracts complete numbers by scanning left and right
- `findNumbersAdjacentTo()` checks all 8 adjacent cells for digits
- Numbers are extracted once per symbol that touches them
- Optimal complexity - must examine each cell and process adjacent numbers

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Consider preprocessing** number positions if multiple queries needed
3. **Early termination** when symbol has no adjacent digits could improve average case
4. **Use appropriate data structures** (`Grid` from third-party module) for grid operations

---

*Last updated: 2025*
*For general Big O notation reference, see [README.md](./README.md)*
