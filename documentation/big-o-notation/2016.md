# Big O Notation Analysis - Advent of Code 2016

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2016 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `Day1.java` | O(n) | O(nÃ—s) | n = instructions, s = steps per instruction. Part 2 checks each step for revisits. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day2 | `BathroomSecurity3.java` | O(nÃ—m) | O(nÃ—m) | n = lines, m = chars per line. Processes each character. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day3 | `Day3.java` | O(n) | O(n) | n = triangles. Part 2 processes in groups of 3. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day4 | `Day4.java` | O(nÃ—L log L) | O(nÃ—L) | n = rooms, L = name length. Part 1 sorts characters. | Already optimal. Sorting is necessary for checksum. | âœ… OK - Already optimal |
| Day5 | `Day5.java` | O(k) | O(k) | k = number to find (MD5 hash). Brute force search. | Already optimal for brute force. Could parallelize MD5 computation. | ðŸŸ¢ LOW - Brute force is expected, could parallelize |
| Day6 | `Day6.java` | O(nÃ—L) | O(nÃ—L) | n = lines, L = message length. Counts characters per column. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day7 | `Day7.java` | O(nÃ—L) | O(nÃ—L) | n = IPs, L = IP length. Pattern matching for ABBA/ABA. | Already optimal. Pattern matching is necessary. | âœ… OK - Already optimal |
| Day8 | `Day8.java` | O(nÃ—RÃ—C) | O(nÃ—RÃ—C) | n = instructions, RÃ—C = grid size. Processes each instruction. | Already optimal. Grid operations are necessary. | âœ… OK - Already optimal |
| Day9 | `ExplosivesInCyberspace.java` | O(L) | O(LÃ—d) | L = input length, d = nesting depth. Part 2 recursively processes markers. | Already optimal. Recursive processing is necessary. | âœ… OK - Already optimal |
| Day10 | `BalanceBots.java` | O(BÃ—I) | O(BÃ—I) | B = bots, I = iterations. Simulation loop processes bots. | Already optimal. Simulation is necessary. | âœ… OK - Already optimal |
| Day11 | `RTGFacility.java` | O(exp) | O(exp) | BFS state space search. Exponential state space. | Uses BFS with visited set. Could add better heuristics or A*. | ðŸ”´ HIGH - Exponential state space, needs optimization |
| Day12 | `AssembunnyInterpreter.java` | O(n) | O(n) | n = instructions. Linear execution. | Already optimal. Simple interpreter. | âœ… OK - Already optimal |
| Day13 | `MazePathfinder.java` | O(V+E) | O(V+E) | V = vertices, E = edges. BFS traversal. | Already optimal. BFS is optimal for shortest path. | âœ… OK - Already optimal |
| Day14 | `Day14.java` | O(kÃ—1000) | O(kÃ—1000Ã—2016) | k = keys to find. Part 2 uses key stretching (2016 hashes). | Uses hash caching. Already optimized. | âœ… OK - Well optimized with caching |
| Day15 | `Day15.java` | O(T) | O(T) | T = time to find. Brute force search. | Could use Chinese Remainder Theorem for optimization. | ðŸŸ¡ MEDIUM - Can use CRT for better complexity |
| Day16 | `Day16.java` | O(L) | O(L) | L = disk length. Generates dragon curve data. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day17 | `Day17.java` | O(exp) | O(exp) | BFS/DFS state space search. Exponential paths. | Part 1 uses BFS (optimal). Part 2 uses DFS (exponential). | ðŸŸ¡ MEDIUM - Part 2 DFS explores all paths, but necessary |
| Day18 | `Day18.java` | O(RÃ—L) | O(RÃ—L) | R = rows, L = row length. Generates rows sequentially. | Already optimal. Row generation is necessary. | âœ… OK - Already optimal |
| Day19 | `Day19.java` | O(1) | O(1) | Uses Josephus formula. Constant time. | Already optimal. Mathematical formula. | âœ… OK - Already optimal |
| Day20 | `Day20.java` | O(n log n) | O(n log n) | n = ranges. Sorts and merges ranges. | Already optimal. Sorting is necessary for merging. | âœ… OK - Already optimal |
| Day21 | `Day21.java` | O(nÃ—L) | O(nÃ—L) | n = operations, L = string length. String manipulation. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day22 | `GridComputing.java` | O(NÂ²) | O(exp) | N = nodes. Part 1 checks all pairs. Part 2 uses BFS. | Part 1: Already optimal for pair checking. Part 2: BFS is optimal. | âœ… OK - Well optimized |
| Day23 | `AssembunnyInterpreterV2.java` | O(n) | O(n) | n = instructions. Linear execution with toggle support. Uses trampoline pattern to convert recursion to iteration, avoiding stack overflow. Sealed class hierarchy (Instruction interface) for type-safe instruction execution. Part 2 optimizes multiplication loop with mul instruction. | Functional style with sealed classes (DOP/FP principles). Trampoline pattern enables safe deep recursion. Immutable transformations with pure functions. | âœ… OK - Already optimized |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines/instructions
- **L**: Length of string/sequence
- **k**: Number to find (e.g., hash number, keys)
- **m**: Number of characters per line
- **s**: Number of steps per instruction
- **B**: Number of bots
- **I**: Number of iterations
- **R**: Number of rows
- **C**: Number of columns
- **V**: Number of vertices in graph
- **E**: Number of edges in graph
- **T**: Time steps to find
- **N**: Number of nodes
- **d**: Nesting depth
- **exp**: Exponential complexity

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 2, 3, 4, 6, 7, 8, 9, 10, 12, 13, 16, 18, 19, 20, 21, 23
- **O(RÃ—C) or O(RÃ—L)**: Days 8, 18
- **O(V+E)**: Day 13
- **O(NÂ²)**: Day 22 (Part 1)
- **O(exp)**: Days 11, 17, 22 (Part 2)
- **O(k) or O(kÃ—1000)**: Days 5, 14, 15

### Most Critical Improvements Needed

1. **Day11 (RTGFacility)**: Exponential state space - BFS with visited set, but state space is large
   - Could use better state representation/canonicalization
   - Could add heuristics or A* search
   - Could use pattern recognition for state pruning

2. **Day15 (Day15)**: Brute force time search
   - Can use Chinese Remainder Theorem (CRT) for optimization
   - Reduces from O(T) to O(n) where n = number of discs

3. **Day17 (Day17)**: Part 2 uses DFS exploring all paths
   - Exponential complexity but necessary to find longest path
   - Could add memoization if paths repeat

### Performance Notes

- Most linear problems (Days 1-10, 12, 13, 16, 18-21, 23) are already well-optimized
- Grid-based problems (Days 8, 18) are acceptable for typical sizes
- Day11 has exponential complexity but uses BFS with visited set to avoid infinite loops
- Day14 uses hash caching to avoid recomputing MD5 hashes
- Day19 uses mathematical formula (Josephus problem) for O(1) solution
- Day22 Part 2 uses BFS which is optimal for shortest path

### Detailed Analysis

#### Day11 - RTGFacility

**Complexity:** O(exp) - BFS state space search
- State space includes: elevator floor, items on each floor
- State representation uses canonical form for better pruning
- Visited set prevents revisiting states
- For typical inputs: ~10-20 items, state space is manageable

**Optimization:**
- Already uses canonical state representation
- Could add heuristics (e.g., A* with estimated steps remaining)
- Could use pattern recognition to identify equivalent states
- Could optimize state key generation

#### Day15 - Day15

**Complexity:** O(T) - Brute force time search
- Checks each time step until all discs align
- For typical inputs: T can be large (millions)

**Optimization:**
- Use Chinese Remainder Theorem (CRT)
- Reduces complexity to O(n) where n = number of discs
- CRT finds time t such that:
  - (initialPosition[i] + t + discNumber[i]) % positions[i] == 0
  - For all discs i

#### Day17 - Day17

**Complexity:** 
- Part 1: O(V+E) - BFS finds shortest path
- Part 2: O(exp) - DFS explores all paths to find longest

**Optimization:**
- Part 1 already uses BFS (optimal)
- Part 2 DFS is necessary to find longest path
- Could add memoization if paths repeat (unlikely in this problem)
- Could use iterative deepening DFS with depth limit

#### Day22 - GridComputing

**Complexity:**
- Part 1: O(NÂ²) - Checks all node pairs for viability
- Part 2: O(exp) - BFS state space search

**Optimization:**
- Part 1: Already optimal for pair checking
- Part 2: Uses BFS with state representation (goal position + empty position)
- Could add heuristics for A* search
- Could optimize state representation

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Focus optimizations** on Day11 (RTGFacility) first - largest exponential complexity
3. **Consider algorithmic improvements** before micro-optimizations:
   - Day15: Implement Chinese Remainder Theorem
   - Day11: Add A* heuristics or better state pruning
4. **Use appropriate data structures** (priority queues, hash maps) where applicable
5. **Consider memoization** for recursive solutions with overlapping subproblems
6. **Parallelize** brute force searches (Day5, Day14) where possible

---

*Last updated: 2025*
*For general Big O notation reference, see [README.md](./README.md)*
