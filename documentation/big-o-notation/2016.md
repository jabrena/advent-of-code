# Big O Notation Analysis - Advent of Code 2016

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2016 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Test Time | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-----------|-------|--------------|-------------------|
| Day1 | `Day1.java` | O(n) | O(nÃ—s) | 0.003s | n = instructions, s = steps per instruction. Part 2 checks each step for revisits. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day2 | `BathroomSecurity3.java` | O(nÃ—m) | O(nÃ—m) | 0.019s | n = lines, m = chars per line. Processes each character. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day3 | `Day3.java` | O(n) | O(n) | 0.021s | n = triangles. Part 2 processes in groups of 3. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day4 | `Day4.java` | O(nÃ—L log L) | O(nÃ—L) | 0.082s | n = rooms, L = name length. Part 1 sorts characters. | Already optimal. Sorting is necessary for checksum. | âœ… OK - Already optimal |
| Day5 | `Day5.java` | O(k) | O(k) | 3.210s | k = number to find (MD5 hash). Brute force search. Part 2 test disabled (slow). | Already optimal for brute force. Could parallelize MD5 computation. | ðŸ”´ HIGH - Part 2 disabled, slow execution (3.2s) |
| Day6 | `Day6.java` | O(nÃ—L) | O(nÃ—L) | 0.004s | n = lines, L = message length. Counts characters per column. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day7 | `Day7.java` | O(nÃ—L) | O(nÃ—L) | 0.022s | n = IPs, L = IP length. Pattern matching for ABBA/ABA. | Already optimal. Pattern matching is necessary. | âœ… OK - Already optimal |
| Day8 | `Day8.java` | O(nÃ—RÃ—C) | O(nÃ—RÃ—C) | 0.006s | n = instructions, RÃ—C = grid size. Processes each instruction. Uses `Grid` from third-party module. | Already optimal. Grid operations are necessary. | âœ… OK - Already optimal |
| Day9 | `ExplosivesInCyberspace.java` | O(L) | O(LÃ—d) | 0.005s | L = input length, d = nesting depth. Part 2 recursively processes markers. | Already optimal. Recursive processing is necessary. | âœ… OK - Already optimal |
| Day10 | `BalanceBots.java` | O(BÃ—I) | O(BÃ—I) | 0.004s | B = bots, I = iterations. Simulation loop processes bots. | Already optimal. Simulation is necessary. | âœ… OK - Already optimal |
| Day11 | `RTGFacility.java` | O(exp) | O(exp) | 1.196s | BFS state space search. Exponential state space. | Uses BFS with visited set. Could add better heuristics or A*. | ðŸŸ¡ MEDIUM - Exponential but acceptable (1.2s) |
| Day12 | `AssembunnyInterpreter.java` | O(n) | O(n) | 0s (disabled) | n = instructions. Linear execution. Test class disabled. | Already optimal. Simple interpreter. | ðŸŸ¡ MEDIUM - Tests disabled |
| Day13 | `MazePathfinder.java` | O(V+E) | O(V+E) | 0.005s | V = vertices, E = edges. BFS traversal. | Already optimal. BFS is optimal for shortest path. | âœ… OK - Already optimal |
| Day14 | `Day14.java` | O(kÃ—1000) | O(kÃ—1000Ã—2016) | 0s (disabled) | k = keys to find. Part 2 uses key stretching (2016 hashes). Test class disabled. | Uses hash caching. Already optimized. | ðŸŸ¡ MEDIUM - Tests disabled |
| Day15 | `Day15.java` | O(T) | O(T) | 0.019s | T = time to find. Brute force search. | Could use Chinese Remainder Theorem for optimization. | ðŸŸ¢ LOW - Fast execution (0.02s), CRT optional |
| Day16 | `Day16.java` | O(L) | O(L) | 0.274s | L = disk length. Generates dragon curve data. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day17 | `Day17.java` | O(exp) | O(exp) | 0.038s | BFS/DFS state space search. Exponential paths. | Part 1 uses BFS (optimal). Part 2 uses DFS (exponential). | âœ… OK - Fast execution (0.04s) |
| Day18 | `Day18.java` | O(RÃ—L) | O(RÃ—L) | 0.493s | R = rows, L = row length. Generates rows sequentially. | Already optimal. Row generation is necessary. | âœ… OK - Already optimal |
| Day19 | `Day19.java` | O(1) | O(1) | 0.004s | Uses Josephus formula. Constant time. | Already optimal. Mathematical formula. | âœ… OK - Already optimal |
| Day20 | `Day20.java` | O(n log n) | O(n log n) | 0.011s | n = ranges. Sorts and merges ranges. | Already optimal. Sorting is necessary for merging. | âœ… OK - Already optimal |
| Day21 | `Day21.java` | O(nÃ—L) | O(nÃ—L) | 0.003s | n = operations, L = string length. String manipulation. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day22 | `GridComputing.java` | O(NÂ²) | O(exp) | 0.271s | N = nodes. Part 1 checks all pairs. Part 2 uses BFS. | Part 1: Already optimal for pair checking. Part 2: BFS is optimal. | âœ… OK - Well optimized |
| Day23 | `AssembunnyInterpreterV2.java` | O(n) | O(n) | 0.342s | n = instructions. Linear execution with toggle support. Uses trampoline pattern to convert recursion to iteration, avoiding stack overflow. Sealed class hierarchy (Instruction interface) for type-safe instruction execution. Part 2 optimizes multiplication loop with mul instruction. | Functional style with sealed classes (DOP/FP principles). Trampoline pattern enables safe deep recursion. Immutable transformations with pure functions. | âœ… OK - Already optimized |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines/instructions
- **L**: Length of string/sequence
- **k**: Number to find (e.g., hash number, keys)
- **m**: Number of characters per line
- **s**: Number of steps per instruction
- **B**: Number of bots
- **I**: Number of iterations
- **R**: Number of rows
- **C**: Number of columns
- **V**: Number of vertices in graph
- **E**: Number of edges in graph
- **T**: Time steps to find
- **N**: Number of nodes
- **d**: Nesting depth
- **exp**: Exponential complexity

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 2, 3, 4, 6, 7, 8, 9, 10, 12, 13, 16, 18, 19, 20, 21, 23
- **O(RÃ—C) or O(RÃ—L)**: Days 8, 18
- **O(V+E)**: Day 13
- **O(NÂ²)**: Day 22 (Part 1)
- **O(exp)**: Days 11, 17, 22 (Part 2)
- **O(k) or O(kÃ—1000)**: Days 5, 14, 15

### Execution Time Analysis (from `./mvnw clean verify`)

**Total Build Time:** 9.297s

**Performance Categories:**
- **Very Fast (< 0.01s):** Days 1, 6, 8, 9, 10, 13, 19, 21 (8 days)
- **Fast (0.01-0.1s):** Days 2, 3, 4, 7, 15, 17, 20 (7 days)
- **Moderate (0.1-0.5s):** Days 11, 16, 18, 22, 23 (5 days)
- **Slow (> 0.5s):** Day 5 (3.210s) - Part 2 test disabled
- **Disabled Tests:** Days 5 (Part 2), 12 (all), 14 (all)

**Key Observations:**
- Day 5 is the slowest (3.2s) with Part 2 disabled due to performance
- Day 11 (1.2s) has exponential complexity but execution time is acceptable
- Days 18, 22, 23 (0.3-0.5s) have moderate execution times but are well-optimized
- Most days execute in under 0.1s, indicating good optimization

### Most Critical Improvements Needed

1. **Day5 (Day5)**: Slowest execution (3.210s), Part 2 test disabled
   - MD5 brute force search is computationally expensive
   - Part 2 test disabled with note: "implementation may be incomplete or slow"
   - Could parallelize MD5 computation across multiple threads
   - Consider using faster hash algorithms or optimized MD5 implementations

2. **Day12 (AssembunnyInterpreter)**: Test class completely disabled
   - Implementation exists but tests are not running
   - Need to investigate why tests are disabled
   - May indicate performance or correctness issues

3. **Day14 (Day14)**: Test class completely disabled
   - Implementation exists but tests are not running
   - Key stretching (2016 hashes) may be too slow for tests
   - Need to investigate why tests are disabled

4. **Day11 (RTGFacility)**: Exponential state space but acceptable execution (1.196s)
   - BFS with visited set works well for current inputs
   - Could add better state representation/canonicalization for larger inputs
   - Could add heuristics or A* search for optimization
   - Could use pattern recognition for state pruning

5. **Day15 (Day15)**: Fast execution (0.019s) but could be optimized
   - Can use Chinese Remainder Theorem (CRT) for optimization
   - Reduces from O(T) to O(n) where n = number of discs
   - Current brute force is acceptable for test inputs

### Performance Notes

- **Most linear problems (Days 1-10, 12, 13, 16, 18-21, 23) are already well-optimized**
  - 15 days execute in under 0.1s
  - Day 1, 6, 8, 9, 10, 13, 19, 21 execute in under 0.01s
- **Grid-based problems (Days 8, 18) are acceptable for typical sizes**
  - Day 8: 0.006s (very fast)
  - Day 18: 0.493s (moderate, but acceptable for row generation)
- **Day11 has exponential complexity but execution time is acceptable (1.196s)**
  - Uses BFS with visited set to avoid infinite loops
  - State space is manageable for current inputs
  - Performance is acceptable but could be optimized for larger inputs
- **Day14 uses hash caching to avoid recomputing MD5 hashes**
  - Test class disabled - may indicate performance issues with key stretching
- **Day19 uses mathematical formula (Josephus problem) for O(1) solution**
  - Executes in 0.004s (very fast)
- **Day22 Part 2 uses BFS which is optimal for shortest path**
  - Executes in 0.271s (moderate, acceptable)
- **Day5 is the performance bottleneck (3.210s)**
  - MD5 brute force search is computationally expensive
  - Part 2 test disabled due to slow execution
  - Primary candidate for optimization or parallelization

### Detailed Analysis

#### Day5 - Day5

**Complexity:** O(k) - MD5 brute force search
- k = number to find (MD5 hash)
- Brute force search through hash space
- **Execution Time:** 3.210s (slowest in the module)
- **Status:** Part 2 test disabled with note: "implementation may be incomplete or slow"

**Optimization:**
- Primary performance bottleneck
- Could parallelize MD5 computation across multiple threads
- Could use optimized MD5 implementations (native libraries)
- Consider alternative approaches if MD5 is not strictly required
- **Priority:** HIGH - Part 2 test is disabled

#### Day11 - RTGFacility

**Complexity:** O(exp) - BFS state space search
- State space includes: elevator floor, items on each floor
- State representation uses canonical form for better pruning
- Visited set prevents revisiting states
- **Execution Time:** 1.196s (acceptable for exponential algorithm)
- For typical inputs: ~10-20 items, state space is manageable

**Optimization:**
- Already uses canonical state representation
- Performance is acceptable for current inputs
- Could add heuristics (e.g., A* with estimated steps remaining) for larger inputs
- Could use pattern recognition to identify equivalent states
- Could optimize state key generation
- **Priority:** MEDIUM - Current performance acceptable, optimization optional

#### Day12 - AssembunnyInterpreter

**Complexity:** O(n) - Linear execution
- n = instructions
- Simple interpreter execution
- **Execution Time:** 0s (test class disabled)
- **Status:** Test class completely disabled

**Optimization:**
- Need to investigate why tests are disabled
- May indicate performance or correctness issues
- **Priority:** MEDIUM - No test coverage

#### Day14 - Day14

**Complexity:** O(kÃ—1000) / O(kÃ—1000Ã—2016)
- k = keys to find
- Part 1: 1000 hash iterations per key
- Part 2: Key stretching with 2016 additional hashes
- Uses hash caching to avoid recomputing MD5 hashes
- **Execution Time:** 0s (test class disabled)
- **Status:** Test class completely disabled

**Optimization:**
- Need to investigate why tests are disabled
- Key stretching (2016 hashes) may be too slow for tests
- Could optimize hash caching strategy
- **Priority:** MEDIUM - No test coverage

#### Day15 - Day15

**Complexity:** O(T) - Brute force time search
- Checks each time step until all discs align
- For typical inputs: T can be large (millions)
- **Execution Time:** 0.019s (fast execution)

**Optimization:**
- Use Chinese Remainder Theorem (CRT)
- Reduces complexity to O(n) where n = number of discs
- CRT finds time t such that:
  - (initialPosition[i] + t + discNumber[i]) % positions[i] == 0
  - For all discs i
- **Priority:** LOW - Current performance is good, optimization optional

#### Day17 - Day17

**Complexity:** 
- Part 1: O(V+E) - BFS finds shortest path
- Part 2: O(exp) - DFS explores all paths to find longest
- **Execution Time:** 0.038s (fast execution despite exponential Part 2)

**Optimization:**
- Part 1 already uses BFS (optimal)
- Part 2 DFS is necessary to find longest path
- Performance is good for current inputs
- Could add memoization if paths repeat (unlikely in this problem)
- Could use iterative deepening DFS with depth limit
- **Priority:** LOW - Current performance is acceptable

#### Day22 - GridComputing

**Complexity:**
- Part 1: O(NÂ²) - Checks all node pairs for viability
- Part 2: O(exp) - BFS state space search
- **Execution Time:** 0.271s (moderate, acceptable)

**Optimization:**
- Part 1: Already optimal for pair checking
- Part 2: Uses BFS with state representation (goal position + empty position)
- Performance is acceptable for current inputs
- Could add heuristics for A* search for larger inputs
- Could optimize state representation
- **Priority:** LOW - Current performance is acceptable

## Recommendations

### Priority 1: Critical Performance Issues

1. **Day5 (Day5) - Slowest execution (3.210s), Part 2 disabled**
   - **Action:** Investigate and optimize MD5 brute force search
   - **Options:**
     - Parallelize MD5 computation across multiple threads/cores
     - Use optimized MD5 implementations (native libraries)
     - Consider alternative approaches if MD5 is not strictly required
   - **Impact:** High - Part 2 test is disabled, indicating significant performance issues

2. **Day12 (AssembunnyInterpreter) - Test class disabled**
   - **Action:** Investigate why tests are disabled
   - **Options:**
     - Re-enable tests if implementation is correct
     - Optimize if performance is the issue
     - Fix correctness issues if present
   - **Impact:** Medium - No test coverage for this day

3. **Day14 (Day14) - Test class disabled**
   - **Action:** Investigate why tests are disabled
   - **Options:**
     - Re-enable tests if implementation is correct
     - Optimize key stretching (2016 hashes) if too slow
     - Consider caching strategies for hash computation
   - **Impact:** Medium - No test coverage for this day

### Priority 2: Optimization Opportunities

4. **Day11 (RTGFacility) - Exponential complexity (1.196s execution)**
   - **Action:** Consider optimizations for larger inputs
   - **Options:**
     - Add A* heuristics with estimated steps remaining
     - Improve state representation/canonicalization
     - Use pattern recognition for state pruning
   - **Impact:** Low - Current performance is acceptable, but could improve scalability

5. **Day15 (Day15) - Fast but could be optimized (0.019s)**
   - **Action:** Implement Chinese Remainder Theorem (CRT)
   - **Options:**
     - Replace brute force with CRT algorithm
     - Reduces complexity from O(T) to O(n) where n = number of discs
   - **Impact:** Low - Current performance is good, optimization is optional

### Priority 3: General Best Practices

6. **Use appropriate data structures** (priority queues, hash maps) where applicable
7. **Consider memoization** for recursive solutions with overlapping subproblems
8. **Profile actual execution times** regularly using `./mvnw clean verify` to identify regressions
9. **Monitor test execution times** to catch performance degradation early

---

*Last updated: December 2025 (includes execution time analysis from `./mvnw clean verify`)*
*For general Big O notation reference, see [README.md](./README.md)*
