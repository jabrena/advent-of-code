# Big O Notation Analysis - Advent of Code 2016

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2016 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Test Time | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-----------|-------|--------------|-------------------|
| Day1 | [`NoTimeForATaxicab.java`](../../2016/src/main/java/info/jab/aoc2016/day1/NoTimeForATaxicab.java) | O(n) | O(nÃ—s) | 0.003s | n = instructions, s = steps per instruction. Part 2 checks each step for revisits. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day2 | [`BathroomSecurity3.java`](../../2016/src/main/java/info/jab/aoc2016/day2/BathroomSecurity3.java) | O(nÃ—m) | O(nÃ—m) | 0.019s | n = lines, m = chars per line. Processes each character. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day3 | [`TriangleValidator.java`](../../2016/src/main/java/info/jab/aoc2016/day3/TriangleValidator.java) | O(n) | O(n) | 0.021s | n = triangles. Part 2 processes in groups of 3. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day4 | [`SecurityThroughObscurity.java`](../../2016/src/main/java/info/jab/aoc2016/day4/SecurityThroughObscurity.java) | O(nÃ—L log L) | O(nÃ—L) | 0.082s | n = rooms, L = name length. Part 1 sorts characters. | Already optimal. Sorting is necessary for checksum. | âœ… OK - Already optimal |
| Day5 | [`HowAboutANiceGameOfChess.java`](../../2016/src/main/java/info/jab/aoc2016/day5/HowAboutANiceGameOfChess.java) | O(k) | O(k) | 1.619s | k = number to find (MD5 hash). Brute force search with parallel processing. Both parts enabled with 30s timeout. | Optimized with parallel streams and zero-allocation MD5 checks. Processes batches of 10,000 indices concurrently. | âœ… OK - Optimized with parallel processing, both parts enabled |
| Day6 | [`SignalsAndNoise.java`](../../2016/src/main/java/info/jab/aoc2016/day6/SignalsAndNoise.java) | O(nÃ—L) | O(nÃ—L) | 0.004s | n = lines, L = message length. Counts characters per column. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day7 | [`InternetProtocolVersion7.java`](../../2016/src/main/java/info/jab/aoc2016/day7/InternetProtocolVersion7.java) | O(nÃ—L) | O(nÃ—L) | 0.022s | n = IPs, L = IP length. Pattern matching for ABBA/ABA. | Already optimal. Pattern matching is necessary. | âœ… OK - Already optimal |
| Day8 | [`TwoFactorAuthentication.java`](../../2016/src/main/java/info/jab/aoc2016/day8/TwoFactorAuthentication.java) | O(nÃ—RÃ—C) | O(nÃ—RÃ—C) | 0.006s | n = instructions, RÃ—C = grid size. Processes each instruction. Uses `Grid` from third-party module. | Already optimal. Grid operations are necessary. | âœ… OK - Already optimal |
| Day9 | [`ExplosivesInCyberspace.java`](../../2016/src/main/java/info/jab/aoc2016/day9/ExplosivesInCyberspace.java) | O(L) | O(LÃ—d) | 0.005s | L = input length, d = nesting depth. Part 2 recursively processes markers. | Already optimal. Recursive processing is necessary. | âœ… OK - Already optimal |
| Day10 | [`BalanceBots.java`](../../2016/src/main/java/info/jab/aoc2016/day10/BalanceBots.java) | O(BÃ—I) | O(BÃ—I) | 0.004s | B = bots, I = iterations. Simulation loop processes bots. | Already optimal. Simulation is necessary. | âœ… OK - Already optimal |
| Day11 | [`RTGFacility.java`](../../2016/src/main/java/info/jab/aoc2016/day11/RTGFacility.java) | O(exp) | O(exp) | 1.342s | A* state space search with heuristic. Exponential state space. | Optimized with A* search using admissible heuristic (items not on top floor). Priority queue prioritizes promising states. | âœ… OK - Optimized with A* heuristic |
| Day12 | [`AssembunnyInterpreter.java`](../../2016/src/main/java/info/jab/aoc2016/day12/AssembunnyInterpreter.java) | O(n) | O(n) | 0.094s | n = instructions. Linear execution. Both parts enabled with 120s timeout. | Optimized with pre-parsed instructions and array-based execution. | âœ… OK - Optimized |
| Day13 | [`MazePathfinder.java`](../../2016/src/main/java/info/jab/aoc2016/day13/MazePathfinder.java) | O(V+E) | O(V+E) | 0.005s | V = vertices, E = edges. BFS traversal. | Already optimal. BFS is optimal for shortest path. | âœ… OK - Already optimal |
| Day14 | [`OneTimePad.java`](../../2016/src/main/java/info/jab/aoc2016/day14/OneTimePad.java) | O(kÃ—1000) | O(kÃ—1000Ã—2016) | 1.705s | k = keys to find. Part 2 uses key stretching (2016 hashes). Both parts enabled with timeouts. | Optimized with sliding window and local MD5 reuse to minimize recomputation. | âœ… OK - Optimized with sliding window, both parts enabled |
| Day15 | [`TimingIsEverything.java`](../../2016/src/main/java/info/jab/aoc2016/day15/TimingIsEverything.java) | O(n) | O(n) | 0.007s | n = number of discs. Uses Chinese Remainder Theorem (CRT). | Optimized with CRT algorithm. Reduces from O(T) brute force to O(n) mathematical solution. | âœ… OK - Optimized with CRT |
| Day16 | [`DragonChecksum.java`](../../2016/src/main/java/info/jab/aoc2016/day16/DragonChecksum.java) | O(L) | O(L) | 0.379s | L = disk length. Generates dragon curve data. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day17 | [`TwoStepsForward.java`](../../2016/src/main/java/info/jab/aoc2016/day17/TwoStepsForward.java) | O(exp) | O(exp) | 0.038s | BFS/DFS state space search. Exponential paths. | Part 1 uses BFS (optimal). Part 2 uses DFS (exponential). | âœ… OK - Fast execution (0.04s) |
| Day18 | [`LikeARogue.java`](../../2016/src/main/java/info/jab/aoc2016/day18/LikeARogue.java) | O(RÃ—L) | O(RÃ—L) | 0.590s | R = rows, L = row length. Generates rows sequentially. | Already optimal. Row generation is necessary. | âœ… OK - Already optimal |
| Day19 | [`AnElephantNamedJoseph.java`](../../2016/src/main/java/info/jab/aoc2016/day19/AnElephantNamedJoseph.java) | O(1) | O(1) | 0.004s | Uses Josephus formula. Constant time. | Already optimal. Mathematical formula. | âœ… OK - Already optimal |
| Day20 | [`FirewallRules.java`](../../2016/src/main/java/info/jab/aoc2016/day20/FirewallRules.java) | O(n log n) | O(n log n) | 0.011s | n = ranges. Sorts and merges ranges. | Already optimal. Sorting is necessary for merging. | âœ… OK - Already optimal |
| Day21 | [`ScrambledLettersAndHash.java`](../../2016/src/main/java/info/jab/aoc2016/day21/ScrambledLettersAndHash.java) | O(nÃ—L) | O(nÃ—L) | 0.003s | n = operations, L = string length. String manipulation. | Already optimal. String operations are necessary. | âœ… OK - Already optimal |
| Day22 | [`GridComputing.java`](../../2016/src/main/java/info/jab/aoc2016/day22/GridComputing.java) | O(NÂ²) | O(exp) | 0.274s | N = nodes. Part 1 checks all pairs. Part 2 uses BFS. | Part 1: Already optimal for pair checking. Part 2: BFS is optimal. | âœ… OK - Well optimized |
| Day23 | [`AssembunnyInterpreter.java`](../../2016/src/main/java/info/jab/aoc2016/day23/AssembunnyInterpreter.java) | O(n) | O(n) | 0.343s | n = instructions. Linear execution with toggle support. Uses trampoline pattern to convert recursion to iteration, avoiding stack overflow. Sealed class hierarchy (Instruction interface) for type-safe instruction execution. Part 2 optimizes multiplication loop with mul instruction. | Functional style with sealed classes (DOP/FP principles). Trampoline pattern enables safe deep recursion. Immutable transformations with pure functions. | âœ… OK - Already optimized |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines/instructions
- **L**: Length of string/sequence
- **k**: Number to find (e.g., hash number, keys)
- **m**: Number of characters per line
- **s**: Number of steps per instruction
- **B**: Number of bots
- **I**: Number of iterations
- **R**: Number of rows
- **C**: Number of columns
- **V**: Number of vertices in graph
- **E**: Number of edges in graph
- **T**: Time steps to find
- **N**: Number of nodes
- **d**: Nesting depth
- **exp**: Exponential complexity

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential/factorial complexity that could cause performance issues
  - Significant optimization opportunities

- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved

- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases

- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 2, 3, 4, 6, 7, 8, 9, 10, 12, 13, 16, 18, 19, 20, 21, 23
- **O(RÃ—C) or O(RÃ—L)**: Days 8, 18
- **O(V+E)**: Day 13
- **O(NÂ²)**: Day 22 (Part 1)
- **O(exp)**: Days 11, 17, 22 (Part 2)
- **O(k) or O(kÃ—1000)**: Days 5, 14, 15

### Execution Time Analysis (from `./mvnw clean verify`)

**Total Build Time:** 9.297s

**Performance Categories:**
- **Very Fast (< 0.01s):** Days 1, 6, 8, 9, 10, 13, 19, 21 (8 days)
- **Fast (0.01-0.1s):** Days 2, 3, 4, 7, 12, 15, 17, 20 (8 days)
- **Moderate (0.1-2.0s):** Days 5 (1.62s), 11 (1.34s), 14 (1.71s), 16 (0.38s), 18 (0.59s), 22 (0.27s), 23 (0.34s)
- **Slow (> 2.0s):** None
- **All Tests Enabled:** All days now have active tests with appropriate timeouts

**Key Observations:**
- Day 12 optimized from 32s to 0.09s using pre-parsed interpreter
- Day 5 optimized from 3.5s to 1.6s using zero-allocation MD5 checks
- Day 14 optimized from 12s to 1.7s using sliding window and MD5 reuse
- Day 11 (1.34s) optimized with A* search using admissible heuristic
- All days now execute under 2 seconds

### Most Critical Improvements Needed

1. **Day15 (Day15)**: Fast execution (0.019s) but could be optimized
   - Can use Chinese Remainder Theorem (CRT) for optimization
   - Reduces from O(T) to O(n) where n = number of discs
   - Current brute force is acceptable for test inputs

### Performance Notes

- **Most linear problems (Days 1-10, 12, 13, 16, 18-21, 23) are already well-optimized**
  - 15 days execute in under 0.1s
  - Day 1, 6, 8, 9, 10, 13, 19, 21 execute in under 0.01s
- **Grid-based problems (Days 8, 18) are acceptable for typical sizes**
  - Day 8: 0.006s (very fast)
  - Day 18: 0.493s (moderate, but acceptable for row generation)
- **Day11 optimized with A* search (1.420s)**
  - Uses A* with admissible heuristic (items not on top floor)
  - Priority queue prioritizes promising states for faster convergence
  - Performance improved through intelligent state exploration
- **Day14 optimized with sliding window (1.705s)**
  - Sliding window of 2000 hashes to batch computations
  - Local MD5 reuse to minimize redundant hash computations
  - Both parts enabled with 60s/120s timeout protection
  - Performance improved through efficient hash caching
- **Day12 tests re-enabled (32.31s)**
  - Simple interpreter, linear execution
  - Both parts enabled with 30s/120s timeout protection
  - Performance acceptable for interpreter-based solution
- **Day19 uses mathematical formula (Josephus problem) for O(1) solution**
  - Executes in 0.004s (very fast)
- **Day22 Part 2 uses BFS which is optimal for shortest path**
  - Executes in 0.271s (moderate, acceptable)
- **Day5 optimized with parallel processing (3.498s)**
  - MD5 brute force search parallelized using Java parallel streams
  - Processes batches of 10,000 indices concurrently
  - Both parts now enabled with 30s timeout protection
  - Performance improved through concurrent hash computation

### Detailed Analysis

#### Day5 - HowAboutANiceGameOfChess

**Complexity:** O(k) - MD5 brute force search with parallel processing
- k = number to find (MD5 hash)
- Brute force search through hash space
- **Execution Time:** 1.722s (both parts, optimized)
- **Status:** Both parts enabled with 30s timeout protection

**Optimization:**
- âœ… Optimized with parallel streams and zero-allocation MD5 checks
- Processes batches of 10,000 indices in parallel
- Avoids String allocation for non-matching hashes
- **Execution Time:** 1.619s (both parts, optimized)
- **Priority:** âœ… OK - Optimized and both parts enabled

#### Day11 - RTGFacility

**Complexity:** O(exp) - A* state space search with heuristic
- State space includes: elevator floor, items on each floor
- State representation uses canonical form for better pruning
- Visited set prevents revisiting states
- **Execution Time:** 1.420s (optimized with A*)
- For typical inputs: ~10-20 items, state space is manageable

**Optimization:**
- âœ… Optimized with A* search using admissible heuristic
- Priority queue prioritizes states with lower estimated total cost (steps + heuristic)
- Heuristic: (items not on top floor + 1) / 2 (minimum moves needed)
- A* ensures optimal solution while exploring fewer states than BFS
- **Execution Time:** 1.342s (optimized with A*)
- **Priority:** âœ… OK - Optimized with A* heuristic

#### Day12 - AssembunnyInterpreter

**Complexity:** O(n) - Linear execution
- n = instructions
- Simple interpreter execution
- **Execution Time:** 0.082s (both parts, enabled)
- **Status:** Both parts enabled with 30s/120s timeout protection

**Optimization:**
- âœ… Optimized with pre-parsed instructions and int[] registers
- Replaced Map lookups with array access
- Removed String parsing from execution loop
- Performance improved from ~32s to 0.09s
- **Execution Time:** 0.094s (both parts, enabled)
- **Priority:** âœ… OK - Tests enabled, excellent performance

#### Day14 - OneTimePad

**Complexity:** O(kÃ—1000) / O(kÃ—1000Ã—2016) with parallel processing
- k = keys to find
- Part 1: 1000 hash iterations per key
- Part 2: Key stretching with 2016 additional hashes
- Uses sliding window to minimize recomputation
- **Execution Time:** 1.461s (both parts, optimized)
- **Status:** Both parts enabled with 60s/120s timeout protection

**Optimization:**
- âœ… Optimized with sliding window and local MD5 reuse
- Eliminated redundant hash computations
- Minimized object allocation during MD5 hashing
- Uses sliding window of 2000 hashes to batch computations
- Performance improved from ~12s to 1.7s
- **Execution Time:** 1.705s (both parts, optimized)
- **Priority:** âœ… OK - Optimized with sliding window, both parts enabled

#### Day15 - TimingIsEverything

**Complexity:** O(n) - Chinese Remainder Theorem (CRT)
- n = number of discs
- Solves system of congruences: t â‰¡ (-initialPosition[i] - discNumber[i]) mod positions[i]
- **Execution Time:** 0.007s (optimized with CRT)

**Optimization:**
- âœ… Implemented Chinese Remainder Theorem (CRT)
- Reduces complexity from O(T) brute force to O(n) where n = number of discs
- CRT finds time t such that:
  - (initialPosition[i] + t + discNumber[i]) % positions[i] == 0
  - For all discs i
- Uses extended Euclidean algorithm for modular inverses
- Mathematical solution eliminates need for brute force iteration
- **Priority:** âœ… OK - Optimized with CRT

#### Day17 - TwoStepsForward

**Complexity:**
- Part 1: O(V+E) - BFS finds shortest path
- Part 2: O(exp) - DFS explores all paths to find longest
- **Execution Time:** 0.038s (fast execution despite exponential Part 2)

**Optimization:**
- Part 1 already uses BFS (optimal)
- Part 2 DFS is necessary to find longest path
- Performance is good for current inputs
- Could add memoization if paths repeat (unlikely in this problem)
- Could use iterative deepening DFS with depth limit
- **Priority:** LOW - Current performance is acceptable

#### Day22 - GridComputing

**Complexity:**
- Part 1: O(NÂ²) - Checks all node pairs for viability
- Part 2: O(exp) - BFS state space search
- **Execution Time:** 0.271s (moderate, acceptable)

**Optimization:**
- Part 1: Already optimal for pair checking
- Part 2: Uses BFS with state representation (goal position + empty position)
- Performance is acceptable for current inputs
- Could add heuristics for A* search for larger inputs
- Could optimize state representation
- **Priority:** LOW - Current performance is acceptable

## Recommendations

### Priority 1: Optimization Opportunities

1. **All optimizations completed** âœ…
   - Day15: Implemented Chinese Remainder Theorem (CRT)
   - Day5: Optimized with zero-allocation MD5 checks
   - Day12: Optimized with pre-parsed instructions
   - Day14: Optimized with sliding window and MD5 reuse

### Priority 3: General Best Practices

6. **Use appropriate data structures** (priority queues, hash maps) where applicable
7. **Consider memoization** for recursive solutions with overlapping subproblems
8. **Profile actual execution times** regularly using `./mvnw clean verify` to identify regressions
9. **Monitor test execution times** to catch performance degradation early

---

*Last updated: December 2025 (includes execution time analysis from `./mvnw test -pl 2016`)*
*For general Big O notation reference, see [README.md](./README.md)*
