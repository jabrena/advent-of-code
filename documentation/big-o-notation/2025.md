# Big O Notation Analysis - Advent of Code 2025

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2025 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `DialRotator.java` | O(n) | O(nÃ—d) | Part 1: Single pass through rotations, each rotation is O(1). Part 2: Expands each rotation into d steps, then processes each step individually. | Part 2: Could optimize by calculating final position directly without expanding to steps. Use modular arithmetic to count zeros during rotation. | ðŸŸ¡ MEDIUM - Part 2 expands rotations unnecessarily, can be optimized to O(n) |
| Day2 | `InvalidIdValidator2.java` | O(RÃ—L) | O(RÃ—LÂ²) | Part 1: For each ID in ranges (R total IDs), check if invalid (O(L) string operations). Part 2: For each ID, try all part lengths (O(L)) and check all parts (O(L/partLength)). | Part 2: Early termination when first valid part length found. Consider using regex patterns or more efficient string matching. Could potentially optimize to O(RÃ—L) with better algorithm. | ðŸŸ¡ MEDIUM - Part 2 quadratic in ID length, could be optimized |

## Legend

### Variable Definitions

- **n**: Number of rotations/operations
- **d**: Average distance per rotation
- **R**: Total number of IDs across all ranges
- **L**: Average length of ID string
- **r**: Number of ranges

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n)**: Day1 Part 1
- **O(nÃ—d)**: Day1 Part 2
- **O(RÃ—L)**: Day2 Part 1
- **O(RÃ—LÂ²)**: Day2 Part 2

### Most Critical Improvements Needed

1. **Day1 Part 2**: Expands rotations into individual steps unnecessarily. Can be optimized to O(n) by calculating zero crossings directly.
2. **Day2 Part 2**: Quadratic complexity in ID length. Could potentially be optimized with better string matching algorithms.

### Performance Notes

- **Day1**: Part 1 is already optimal. Part 2 has room for optimization by avoiding step-by-step expansion.
- **Day2**: Both parts are functional and correct, but Part 2 could benefit from algorithmic improvements to reduce complexity.

### Detailed Analysis

#### Day1 - DialRotator

**Part 1 Analysis:**
- Reads n rotations from file: O(n)
- Filters invalid rotations: O(n)
- Maps to Rotation objects: O(n)
- Reduces with state updates: O(n) - each rotation is O(1)
- **Overall: O(n)** âœ…

**Part 2 Analysis:**
- Reads n rotations: O(n)
- Expands each rotation of distance d into d steps: O(nÃ—d) where d is average distance
- Processes each step: O(nÃ—d)
- **Overall: O(nÃ—d)** ðŸŸ¡

**Optimization Opportunity:**
Instead of expanding rotations into steps, calculate zero crossings directly:
- For a rotation of distance d, calculate how many times position 0 is crossed
- Use modular arithmetic: zero crossings = âŒŠ(currentPosition + d) / DIAL_MAXâŒ‹
- This reduces Part 2 to O(n)

#### Day2 - InvalidIdValidator2

**Part 1 Analysis:**
- Parses ranges: O(r) where r is number of ranges
- Generates all IDs in ranges: O(R) where R is total IDs
- For each ID (R total):
  - Convert to string: O(L) where L is ID length
  - Check if even length: O(1)
  - Compare halves: O(L)
- **Overall: O(RÃ—L)** âœ…

**Part 2 Analysis:**
- Parses ranges: O(r)
- Generates all IDs: O(R)
- For each ID (R total):
  - Convert to string: O(L)
  - Try all part lengths from 1 to L/2: O(L) iterations
  - For each part length, check all parts: O(L/partLength) comparisons
  - Each comparison: O(partLength) string comparison
- **Overall: O(RÃ—LÂ²)** ðŸŸ¡

**Optimization Opportunity:**
- Use more efficient pattern matching
- Early termination optimizations
- Consider using regex for repeated patterns: `^(.+)\1+$` (though this may not be more efficient)
- Could potentially reduce to O(RÃ—L) with better algorithm

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Focus optimizations** on Day1 Part 2 and Day2 Part 2
3. **Consider algorithmic improvements** before micro-optimizations
4. **Use mathematical properties** to avoid unnecessary expansions (Day1 Part 2)
5. **Optimize string operations** where possible (Day2 Part 2)

## Code Quality Notes

- **Day1**: Well-structured with functional programming approach. Good separation of concerns with DialState and Rotation records.
- **Day2**: Clean functional implementation with InvalidIdValidator2. Good use of streams and pure functions.

---

*Last updated: 2025*
*For general Big O notation reference, see [README.md](./README.md)*
