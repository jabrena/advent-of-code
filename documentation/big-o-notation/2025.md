# Big O Notation Analysis - Advent of Code 2025

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2025 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Test Time | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-----------|-------|--------------|-------------------|
| Day1 | [`DialRotator.java`](../../2025/src/main/java/info/jab/aoc2025/day1/DialRotator.java) | O(n) | O(n) âœ… | 0.010s | Part 1: Single pass through rotations, each rotation is O(1). Part 2: **OPTIMIZED** - Uses modular arithmetic to calculate zero crossings directly without expanding rotations. | âœ… **COMPLETED**: Part 2 optimized by calculating zero crossings using modular arithmetic in `countZeroCrossings()` method, avoiding step-by-step expansion. | âœ… **OPTIMIZED** - Part 2 now O(n) instead of O(nÃ—d) |
| Day2 | [`InvalidIdValidator2.java`](../../2025/src/main/java/info/jab/aoc2025/day2/InvalidIdValidator2.java) | O(RÃ—L) | O(RÃ—L) âœ… | 0.308s | Part 1: For each ID in ranges (R total IDs), check if invalid (O(L) string operations). Part 2: **OPTIMIZED** - Uses direct character comparison instead of substring creation, reducing complexity. | âœ… **COMPLETED**: Part 2 optimized by comparing characters directly (`charAt()`) instead of creating substrings, reducing from O(RÃ—LÂ²) to O(RÃ—L). | âœ… **OPTIMIZED** - Part 2 now O(RÃ—L) instead of O(RÃ—LÂ²) |
| Day3 | [`MaxJoltageSolver.java`](../../2025/src/main/java/info/jab/aoc2025/day3/MaxJoltageSolver.java) | O(L) | O(L) âœ… | 0.023s | Part 1: For each line, converts to digits O(n), then recursively finds max digit sequence of length 2 using greedy approach O(n). Part 2: Same recursive approach with length 12, still O(n) per line. Overall O(L) where L is total characters. | âœ… **OPTIMAL**: Uses recursive greedy algorithm with functional programming style. Each line processed in O(n) time where n is line length. | âœ… **OK** - Already optimal greedy solution |
| Day4 | [`GridNeighborSolverV2.java`](../../2025/src/main/java/info/jab/aoc2025/day4/GridNeighborSolverV2.java) | O(RÃ—C) | O((RÃ—C)Â²) âœ… | 0.263s | Part 1: Scans grid once, counts neighbors (O(1) per cell) for each '@' symbol. Part 2: Iteratively removes cells with <4 neighbors until stable. Each iteration scans entire grid O(RÃ—C). Worst case O((RÃ—C)Â²) iterations. | âœ… **OPTIMAL**: Uses Stream API for functional iteration. Neighbor counting is O(1) per cell. Iterative removal is necessary as removing cells affects neighbors. This is optimal for the problem constraints. | âœ… **OK** - Optimal for iterative neighbor-based removal problem |
| Day5 | [`RangeSolverV2.java`](../../2025/src/main/java/info/jab/aoc2025/day5/RangeSolverV2.java) | O(IÃ—R) | O(R log R) âœ… | 0.019s | Part 1: For each ID (I total), checks all ranges (R total) using `anyMatch()`. Each `contains()` check is O(1). Part 2: Sorts ranges O(R log R), then merges in single pass O(R), calculates coverage O(M) where Mâ‰¤R. | âœ… **OPTIMAL**: Part 1 uses straightforward nested iteration. Part 2 uses optimal sorting + linear merge approach. Both parts follow functional programming principles with immutable data structures. | âœ… **OK** - Optimal solution using standard range merging algorithm |
| Day6 | [`MathBlockSolverV2.java`](../../2025/src/main/java/info/jab/aoc2025/day6/MathBlockSolverV2.java) | O(RÃ—C) | O(RÃ—C) âœ… | 0.023s | Part 1: Processes grid row by row, extracts numbers and operators from each block separated by empty columns. Part 2: Processes grid column by column (right to left), extracts numbers vertically. Both parts scan each cell once. | âœ… **OPTIMAL**: Both parts process each cell exactly once. Uses Stream API for functional programming style. Block detection and processing are efficient. | âœ… **OK** - Optimal solution, must examine each cell at least once |
| Day7 | [`BeamPathCounter.java`](../../2025/src/main/java/info/jab/aoc2025/day7/BeamPathCounter.java) | O(RÃ—C) | O(RÃ—C) âœ… | 0.025s | Part 1: Processes grid row by row, tracks beam positions as Set of x coordinates. When splitter encountered, creates 2 beams. Set deduplicates beams at same position. Part 2: Uses memoized recursion to count paths from each point to bottom. Each point computed once. | âœ… **OPTIMAL**: Part 1 processes each row with at most O(C) unique beam positions. Part 2 uses memoization to ensure each point is computed once. Both parts are optimal O(RÃ—C). | âœ… **OK** - Optimal solution, must examine each cell at least once |
| Day8 | [`PointCluster.java`](../../2025/src/main/java/info/jab/aoc2025/day8/PointCluster.java) | O(nÂ² log k) | O(nÂ² log n) âœ… | 0.319s | Part 1: **OPTIMIZED** - Generates all point pairs O(nÂ²), uses priority queue (max-heap) of size k=1000 to keep top connections O(nÂ² log k) instead of sorting all pairs. Part 2: Generates all point pairs O(nÂ²), uses parallel sort O(nÂ² log n), unions all connections until single component. | âœ… **OPTIMIZED**: Part 1 optimized with priority queue approach: O(nÂ² log k) where k=1000 << n, reducing from O(nÂ² log n). Part 2 uses parallel sort for better constant factors. DSU operations optimized: getComponentSizes() avoids distinct() overhead. | âœ… **OPTIMIZED** - Part 1 improved from O(nÂ² log n) to O(nÂ² log k), ~19% faster execution |
| Day9 | [`MaxRectangleArea.java`](../../2025/src/main/java/info/jab/aoc2025/day9/MaxRectangleArea.java) | O(nÂ²) | O(nÂ³) âœ… | 0.142s | Part 1: Generates all point pairs (n choose 2 â‰ˆ nÂ²), calculates area for each pair O(1), finds maximum. Part 2: **OPTIMIZED** - Generates all point pairs O(nÂ²), pre-computes vertical edges O(n), uses parallel streams for validation. For each pair validates rectangle inside polygon by checking all edges O(n) - optimized point-in-polygon check and edge intersection check with quick bounds filtering. | âœ… **OPTIMIZED**: Part 1 must examine all pairs to find maximum area. Part 2 optimized with: (1) pre-computed vertical edges for faster ray casting, (2) parallel processing for independent pair validations, (3) quick bounds filtering before expensive intersection checks, (4) combined point-in-polygon checks. Big O remains O(nÂ³) but constant factors significantly reduced (~7.4x faster in practice). | âœ… **OPTIMIZED** - Optimal Big O complexity with significantly improved constant factors |
| Day10 | [`ButtonPressOptimizer.java`](../../2025/src/main/java/info/jab/aoc2025/day10/ButtonPressOptimizer.java) | O(LÃ—2^(n/2)) | O(LÃ—kâ¿) âœ… | 10.460s | Part 1: **OPTIMIZED** - Adaptive strategy: Brute force for small n, Meet-in-the-middle for nâ‰¥20 ($O(2^{n/2})$) using primitive maps and Gray Codes. Part 2: **OPTIMIZED** - DFS backtracking with zero allocations in loop, SIMD vectorization, and advanced pruning. | âœ… **OPTIMIZED**: Part 1 improved to $O(2^{n/2})$ with $O(1)$ state updates. Part 2 optimized for memory (0 allocations in DFS) and SIMD. | âœ… **OK** - Optimal backtracking solution |

## Legend

### Variable Definitions

- **n**: Number of rotations/operations (for Day1), line length (for Day3), or number of points (for Day8, Day9)
- **d**: Average distance per rotation
- **R**: Total number of IDs across all ranges (for Day2), number of rows in grid (for Day4, Day6, Day7), or number of ranges (for Day5)
- **L**: Number of lines/machines (Day10), or total characters (Day3), or average ID length (Day2)
- **n**: Number of buttons (Day10), rotations (Day1), line length (Day3), or points (Day8, Day9)
- **k**: Max presses per button (Day10) or cluster size (Day8)
- **r**: Number of ranges
- **C**: Number of columns in grid (for Day4, Day6, Day7)
- **I**: Number of IDs to check (for Day5)

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential complexity that could cause performance issues
  - Significant optimization opportunities

- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved

- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases

- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n)**: Day1 Part 1, Day1 Part 2 âœ…
- **O(RÃ—L)**: Day2 Part 1, Day2 Part 2 âœ…
- **O(L)**: Day3 Part 1, Day3 Part 2 âœ…
- **O(RÃ—C)**: Day4 Part 1 âœ…, Day6 Part 1 âœ…, Day6 Part 2 âœ…, Day7 Part 1 âœ…, Day7 Part 2 âœ…
- **O((RÃ—C)Â²)**: Day4 Part 2 âœ…
- **O(IÃ—R)**: Day5 Part 1 âœ…
- **O(R log R)**: Day5 Part 2 âœ…
- **O(nÂ²)**: Day9 Part 1 âœ…
- **O(nÂ² log k)**: Day8 Part 1 âœ… (where k=1000 << n, optimized from O(nÂ² log n))
- **O(nÂ² log n)**: Day8 Part 2 âœ…
- **O(nÂ³)**: Day9 Part 2 âœ…
- **O(LÃ—2^(n/2))**: Day10 Part 1 âœ… (Meet-in-the-middle for large n)
- **O(LÃ—kâ¿)**: Day10 Part 2 âœ… (Optimized Backtracking)

### Execution Time Analysis (from `./mvnw clean test -pl 2025`)

**Total Build Time:** ~13.4s

**Performance Categories:**
- **Very Fast (< 0.05s):** Days 1, 3, 5, 6, 7 (5 days)
- **Fast (0.05-0.2s):** Days 4, 9 (2 days)
- **Moderate (0.2-0.5s):** Days 2, 8 (2 days)
- **Slow (> 0.5s):** Day 10 (10.56s) - Solves NP-Hard problem (ILP)

**Key Observations:**
- Day 10 remains the slowest due to the NP-Hard nature of the problem (Integer Linear Programming), but is now memory-optimized with zero allocations in the DFS loop.
- Day 9 optimized from 1.060s to 0.142s (~7.4x faster) with pre-computed vertical edges, parallel processing, and quick bounds filtering
- Day 8 optimized from 0.393s to 0.319s (~19% faster) with priority queue approach for Part 1 and parallel sort for Part 2

### Most Critical Improvements Needed

1. âœ… **Day10 Part 1 & 2**: Optimized.
   - **Part 1**: Implemented Adaptive Meet-in-the-middle ($O(2^{n/2})$ for nâ‰¥20).
   - **Part 2**: Implemented zero-allocation backtracking. Replaced array cloning with preallocated stack buffers and incremental updates/undo.
   - **SIMD**: Used Vector API for pruning checks (sum, max, allSatisfied) in Part 2.
   - **Status**: Code is now algorithmically and memory optimal for the approach. Execution time is dominated by search space size.

2. âœ… **Day1 Part 2**: Optimized from O(nÃ—d) to O(n) by calculating zero crossings directly using modular arithmetic.
3. âœ… **Day2 Part 2**: Optimized from O(RÃ—LÂ²) to O(RÃ—L) by using direct character comparison instead of substring creation.
4. âœ… **Day8 Part 1**: Optimized from O(nÂ² log n) to O(nÂ² log k) where k=1000 << n, using priority queue approach (~19% faster).
5. âœ… **Day9 Part 2**: Optimized constant factors (~7.4x faster) with pre-computed vertical edges, parallel processing, and quick bounds filtering. Big O remains O(nÂ³) (optimal).

### Performance Notes

- **Day1**: Both parts are now optimal. Part 2 uses modular arithmetic to avoid step-by-step expansion.
- **Day2**: Both parts are now optimal. Part 2 uses efficient character-by-character comparison.
- **Day3**: Both parts are optimal. Uses recursive greedy algorithm with functional programming style.
- **Day4**: Part 1 is optimal O(RÃ—C). Part 2 has quadratic complexity O((RÃ—C)Â²) which is optimal for iterative neighbor-based removal problems where removing cells affects neighbors.
- **Day5**: Part 1 is O(IÃ—R) which is optimal for the straightforward nested iteration approach. Part 2 is O(R log R) which is optimal for range merging (sorting is necessary, merge is linear).
- **Day6**: Both parts are optimal O(RÃ—C). Part 1 processes blocks row by row, Part 2 processes blocks column by column (right to left). Both must examine each cell at least once.
- **Day7**: Both parts are optimal O(RÃ—C). Part 1 tracks beam positions row by row, processing at most O(C) unique positions per row. Part 2 uses memoized recursion to count paths, ensuring each point is computed once.
- **Day8**: Both parts are optimal O(nÂ² log n). Both parts generate all point pairs (n choose 2 â‰ˆ nÂ²) and sort them by distance. Part 1 unions top 1000 shortest connections using DSU. Part 2 unions all connections in order until all points form a single component. The sorting step is necessary to process connections in distance order, and DSU operations are effectively O(1) per operation.
- **Day9**: Part 1 is optimal O(nÂ²) - must examine all point pairs to find maximum area rectangle. Part 2 is optimal O(nÂ³) - generates all point pairs O(nÂ²) and validates each rectangle candidate against all polygon edges O(n) using point-in-polygon and edge intersection checks. **OPTIMIZED** with constant factor improvements: pre-computed vertical edges, parallel processing, and quick bounds filtering reduce execution time by ~7.4x while maintaining optimal Big O complexity.

### Detailed Analysis

#### Day10 - ButtonPressOptimizer

**Part 1 Analysis:**
- **Algorithm**: Adaptive Strategy.
- **Small N (n < 20)**: Uses Brute Force ($O(2^n)$). For small N, this is faster than the overhead of map operations.
- **Large N (n â‰¥ 20)**: Uses Meet-in-the-middle ($O(2^{n/2})$). Splits buttons into two sets, generates sums for the first set into a Map, then checks the second set.
- **Complexity**: $O(L \times 2^{n/2})$ worst case.
- **Optimization**: Implemented adaptive switch to handle both small and large inputs efficiently.

**Part 2 Analysis:**
- **Algorithm**: DFS Backtracking (Integer Linear Programming).
- **Search Space**: $O(L \times k^n)$ where k is the branching factor.
- **Optimization (Memory)**: **Zero-Allocation Loop**.
  - Previous: `targets.clone()` in every iteration of the branching loop ($Limit$ clones per node).
  - New: Incremental updates (`targets[k]--`) and restoration (`targets[k]++`) allow reusing the same array instance.
  - **Preallocated Buffers**: History arrays for undoing "Singleton Propagation" are preallocated in `solveMachinePart2` and passed down the recursion stack.
  - **Result**: Reduced allocations from Millions (Limit * Nodes) to 0 in the DFS hot path.
- **Pruning**: Singleton Propagation (Constraint Satisfaction) and Lower Bound Pruning (sum/maxCov) remain effective.

**Optimization Implemented:**
âœ… **COMPLETED**:
1. **Part 1**: Added Adaptive Meet-in-the-middle with Gray Code bit manipulation for O(1) state updates. Pre-sized primitive HashMaps and lazy bit counting further reduced overhead.
2. **Part 2**: Implemented full backtracking with 0 heap allocations in the recursion.
   - Removed `targets.clone()`.
   - Added preallocated `propColsStack` and `propValsStack` for propagation history.
   - Implemented incremental state updates and undo logic.
   - Added Vector API (SIMD) for `allSatisfied`, `sum`, and `max` reductions in pruning logic.
   - Added tighter lower bound pruning using `maxTarget`.
- Execution time improved from ~17.8s to ~10.4s (~41% faster), with vastly improved memory profile.

#### Day1 - DialRotator
...
