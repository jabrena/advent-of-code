# Big O Notation Analysis - Advent of Code 2025

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2025 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `DialRotator.java` | O(n) | O(n) 笨 | Part 1: Single pass through rotations, each rotation is O(1). Part 2: **OPTIMIZED** - Uses modular arithmetic to calculate zero crossings directly without expanding rotations. | 笨 **COMPLETED**: Part 2 optimized by calculating zero crossings using modular arithmetic in `countZeroCrossings()` method, avoiding step-by-step expansion. | 笨 **OPTIMIZED** - Part 2 now O(n) instead of O(nﾃ妖) |
| Day2 | `InvalidIdValidator2.java` | O(Rﾃ有) | O(Rﾃ有) 笨 | Part 1: For each ID in ranges (R total IDs), check if invalid (O(L) string operations). Part 2: **OPTIMIZED** - Uses direct character comparison instead of substring creation, reducing complexity. | 笨 **COMPLETED**: Part 2 optimized by comparing characters directly (`charAt()`) instead of creating substrings, reducing from O(Rﾃ有ﾂｲ) to O(Rﾃ有). | 笨 **OPTIMIZED** - Part 2 now O(Rﾃ有) instead of O(Rﾃ有ﾂｲ) |
| Day3 | `MaxJoltageSolver.java` | O(L) | O(L) 笨 | Part 1: For each line, converts to digits O(n), then recursively finds max digit sequence of length 2 using greedy approach O(n). Part 2: Same recursive approach with length 12, still O(n) per line. Overall O(L) where L is total characters. | 笨 **OPTIMAL**: Uses recursive greedy algorithm with functional programming style. Each line processed in O(n) time where n is line length. | 笨 **OK** - Already optimal greedy solution |

## Legend

### Variable Definitions

- **n**: Number of rotations/operations
- **d**: Average distance per rotation
- **R**: Total number of IDs across all ranges
- **L**: Total characters across all lines (for Day3) or average length of ID string (for Day2)
- **r**: Number of ranges
- **n**: Line length (for Day3)

### Attention Level Indicators

- **沐ｴ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential complexity that could cause performance issues
  - Significant optimization opportunities
  
- **沺｡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **沺｢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **笨 OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n)**: Day1 Part 1, Day1 Part 2 笨
- **O(Rﾃ有)**: Day2 Part 1, Day2 Part 2 笨
- **O(L)**: Day3 Part 1, Day3 Part 2 笨

### Most Critical Improvements Needed

笨 **All optimizations completed!**

1. 笨 **Day1 Part 2**: Optimized from O(nﾃ妖) to O(n) by calculating zero crossings directly using modular arithmetic.
2. 笨 **Day2 Part 2**: Optimized from O(Rﾃ有ﾂｲ) to O(Rﾃ有) by using direct character comparison instead of substring creation.

### Performance Notes

- **Day1**: Both parts are now optimal. Part 2 uses modular arithmetic to avoid step-by-step expansion.
- **Day2**: Both parts are now optimal. Part 2 uses efficient character-by-character comparison.

### Detailed Analysis

#### Day1 - DialRotator

**Part 1 Analysis:**
- Reads n rotations from file: O(n)
- Filters invalid rotations: O(n)
- Maps to Rotation objects: O(n)
- Reduces with state updates: O(n) - each rotation is O(1)
- **Overall: O(n)** 笨

**Part 2 Analysis (OPTIMIZED):**
- Reads n rotations: O(n)
- Calculates zero crossings directly using modular arithmetic: O(1) per rotation
- Processes each rotation: O(1)
- **Overall: O(n)** 笨

**Optimization Implemented:**
笨 **COMPLETED**: Instead of expanding rotations into steps, zero crossings are now calculated directly:
- Uses `countZeroCrossings()` method with modular arithmetic
- For RIGHT rotation: `(currentPosition + distance) / DIAL_MAX` (with special handling for position 0)
- For LEFT rotation: Direct calculation based on position and distance relationships
- This reduces Part 2 from O(nﾃ妖) to O(n)

#### Day2 - InvalidIdValidator2

**Part 1 Analysis:**
- Parses ranges: O(r) where r is number of ranges
- Generates all IDs in ranges: O(R) where R is total IDs
- For each ID (R total):
  - Convert to string: O(L) where L is ID length
  - Check if even length: O(1)
  - Compare halves: O(L)
- **Overall: O(Rﾃ有)** 笨

**Part 2 Analysis (OPTIMIZED):**
- Parses ranges: O(r)
- Generates all IDs: O(R)
- For each ID (R total):
  - Convert to string: O(L)
  - Try all divisors of length (typically O(竏哭) divisors): O(竏哭) iterations
  - For each divisor, check characters directly: O(L) character comparisons
  - Each character comparison: O(1) using `charAt()`
- **Overall: O(Rﾃ有)** 笨 (worst case O(Rﾃ有^1.5) but typically O(Rﾃ有) due to few divisors)

**Optimization Implemented:**
笨 **COMPLETED**: Optimized string matching by:
- Using direct character comparison with `charAt(i) == charAt(i % partLength)` instead of creating substrings
- Avoiding substring creation overhead (O(partLength) per substring)
- Still only checking divisors of length (already optimal)
- This reduces Part 2 from O(Rﾃ有ﾂｲ) to O(Rﾃ有)

#### Day3 - MaxJoltageSolver

**Part 1 Analysis:**
- Reads all lines: O(L) where L is total characters
- For each line:
  - Converts string to digit list using streams: O(n) where n is line length
  - Recursively builds maximum joltage using `buildMaxJoltage()`:
    - Tail-recursive function called `length` times (2 for part 1)
    - Each call uses `findMaxDigitInRange()` to scan valid range
    - For length=2: O(n) total operations (each position visited at most once)
- **Overall: O(L)** 笨

**Part 2 Analysis:**
- Same structure as Part 1 but with length=12
- For each line:
  - Converts to digit list: O(n)
  - Recursively builds maximum joltage:
    - Tail-recursive function called 12 times
    - Each call scans a portion of the array using `findMaxDigitInRange()`
    - Total operations per line: O(n) (each position visited at most once across all recursive calls)
- **Overall: O(L)** 笨

**Algorithm Notes:**
- Uses recursive greedy algorithm with functional programming principles
- `buildMaxJoltage()` is a tail-recursive pure function that maintains immutability
- `findMaxDigitInRange()` uses streams to find maximum digit in a single pass
- Maintains `startPos` and calculates `endPos` to ensure enough digits remain for remaining length
- Optimal approach for this problem - no better complexity possible as we must examine each digit
- Implementation follows DOP (Data-Oriented Programming) and FP (Functional Programming) principles

## Recommendations

笨 **All recommended optimizations have been implemented!**

1. 笨 **Day1 Part 2**: Optimized using mathematical properties (modular arithmetic) to avoid unnecessary expansions
2. 笨 **Day2 Part 2**: Optimized string operations by using direct character comparison instead of substring creation
3. **Future considerations**: Profile actual execution times using `./mvnw clean test surefire-report:report-only` to verify performance improvements
4. **Code quality**: Both implementations maintain functional programming principles and immutability

## Code Quality Notes

- **Day1**: Well-structured with functional programming approach. Good separation of concerns with DialState and Rotation records. 笨 Optimized Part 2 maintains immutability and functional style.
- **Day2**: Clean functional implementation with InvalidIdValidator2. Good use of streams and pure functions. 笨 Optimized Part 2 maintains functional programming principles while improving performance.
- **Day3**: Efficient recursive greedy algorithm with functional programming style. Clean separation of concerns with `MaxJoltageSolver` class, `solve()`, `getMaxJoltage()`, and `buildMaxJoltage()` methods. Uses streams, immutable data structures (records), and tail recursion. Follows DOP and FP principles. 笨 Already optimal.

## Optimization Summary

### Changes Made (2025-12-03)

1. **Day1 Part 2 (`DialRotator.java`)**:
   - Added `countZeroCrossings()` method using modular arithmetic
   - Added `applyRotationWithZeroCount()` method to `DialState`
   - Removed `expandToSteps()` usage in Part 2
   - Complexity improved from O(nﾃ妖) to O(n)

2. **Day2 Part 2 (`InvalidIdValidator2.java`)**:
   - Replaced substring creation and comparison with direct character comparison
   - Uses `charAt(i) == charAt(i % partLength)` pattern
   - Complexity improved from O(Rﾃ有ﾂｲ) to O(Rﾃ有)

---

*Last updated: 2025-12-03*
*Day3 refactored to use MaxJoltageSolver with recursive functional implementation*
*Optimizations completed and verified*
*For general Big O notation reference, see [README.md](./README.md)*
