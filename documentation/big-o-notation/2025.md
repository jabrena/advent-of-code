# Big O Notation Analysis - Advent of Code 2025

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2025 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Test Time | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-----------|-------|--------------|-------------------|
| Day1 | [`DialRotator.java`](../../2025/src/main/java/info/jab/aoc2025/day1/DialRotator.java) | O(n) | O(n) âœ… | 0.010s | Part 1: Single pass through rotations, each rotation is O(1). Part 2: **OPTIMIZED** - Uses modular arithmetic to calculate zero crossings directly without expanding rotations. | âœ… **COMPLETED**: Part 2 optimized by calculating zero crossings using modular arithmetic in `countZeroCrossings()` method, avoiding step-by-step expansion. | âœ… **OPTIMIZED** - Part 2 now O(n) instead of O(nÃ—d) |
| Day2 | [`InvalidIdValidator2.java`](../../2025/src/main/java/info/jab/aoc2025/day2/InvalidIdValidator2.java) | O(RÃ—L) | O(RÃ—L) âœ… | 0.308s | Part 1: For each ID in ranges (R total IDs), check if invalid (O(L) string operations). Part 2: **OPTIMIZED** - Uses direct character comparison instead of substring creation, reducing complexity. | âœ… **COMPLETED**: Part 2 optimized by comparing characters directly (`charAt()`) instead of creating substrings, reducing from O(RÃ—LÂ²) to O(RÃ—L). | âœ… **OPTIMIZED** - Part 2 now O(RÃ—L) instead of O(RÃ—LÂ²) |
| Day3 | [`MaxJoltageSolver.java`](../../2025/src/main/java/info/jab/aoc2025/day3/MaxJoltageSolver.java) | O(L) | O(L) âœ… | 0.023s | Part 1: For each line, converts to digits O(n), then recursively finds max digit sequence of length 2 using greedy approach O(n). Part 2: Same recursive approach with length 12, still O(n) per line. Overall O(L) where L is total characters. | âœ… **OPTIMAL**: Uses recursive greedy algorithm with functional programming style. Each line processed in O(n) time where n is line length. | âœ… **OK** - Already optimal greedy solution |
| Day4 | [`GridNeighborSolverV2.java`](../../2025/src/main/java/info/jab/aoc2025/day4/GridNeighborSolverV2.java) | O(RÃ—C) | O((RÃ—C)Â²) âœ… | 0.263s | Part 1: Scans grid once, counts neighbors (O(1) per cell) for each '@' symbol. Part 2: Iteratively removes cells with <4 neighbors until stable. Each iteration scans entire grid O(RÃ—C). Worst case O((RÃ—C)Â²) iterations. | âœ… **OPTIMAL**: Uses Stream API for functional iteration. Neighbor counting is O(1) per cell. Iterative removal is necessary as removing cells affects neighbors. This is optimal for the problem constraints. | âœ… **OK** - Optimal for iterative neighbor-based removal problem |
| Day5 | [`RangeSolverV2.java`](../../2025/src/main/java/info/jab/aoc2025/day5/RangeSolverV2.java) | O(IÃ—R) | O(R log R) âœ… | 0.019s | Part 1: For each ID (I total), checks all ranges (R total) using `anyMatch()`. Each `contains()` check is O(1). Part 2: Sorts ranges O(R log R), then merges in single pass O(R), calculates coverage O(M) where Mâ‰¤R. | âœ… **OPTIMAL**: Part 1 uses straightforward nested iteration. Part 2 uses optimal sorting + linear merge approach. Both parts follow functional programming principles with immutable data structures. | âœ… **OK** - Optimal solution using standard range merging algorithm |
| Day6 | [`MathBlockSolverV2.java`](../../2025/src/main/java/info/jab/aoc2025/day6/MathBlockSolverV2.java) | O(RÃ—C) | O(RÃ—C) âœ… | 0.023s | Part 1: Processes grid row by row, extracts numbers and operators from each block separated by empty columns. Part 2: Processes grid column by column (right to left), extracts numbers vertically. Both parts scan each cell once. | âœ… **OPTIMAL**: Both parts process each cell exactly once. Uses Stream API for functional programming style. Block detection and processing are efficient. | âœ… **OK** - Optimal solution, must examine each cell at least once |
| Day7 | [`BeamPathCounter.java`](../../2025/src/main/java/info/jab/aoc2025/day7/BeamPathCounter.java) | O(RÃ—C) | O(RÃ—C) âœ… | 0.025s | Part 1: Processes grid row by row, tracks beam positions as Set of x coordinates. When splitter encountered, creates 2 beams. Set deduplicates beams at same position. Part 2: Uses memoized recursion to count paths from each point to bottom. Each point computed once. | âœ… **OPTIMAL**: Part 1 processes each row with at most O(C) unique beam positions. Part 2 uses memoization to ensure each point is computed once. Both parts are optimal O(RÃ—C). | âœ… **OK** - Optimal solution, must examine each cell at least once |
| Day8 | [`PointCluster.java`](../../2025/src/main/java/info/jab/aoc2025/day8/PointCluster.java) | O(nÂ² log k) | O(nÂ² log n) âœ… | 0.319s | Part 1: **OPTIMIZED** - Generates all point pairs O(nÂ²), uses priority queue (max-heap) of size k=1000 to keep top connections O(nÂ² log k) instead of sorting all pairs. Part 2: Generates all point pairs O(nÂ²), uses parallel sort O(nÂ² log n), unions all connections until single component. | âœ… **OPTIMIZED**: Part 1 optimized with priority queue approach: O(nÂ² log k) where k=1000 << n, reducing from O(nÂ² log n). Part 2 uses parallel sort for better constant factors. DSU operations optimized: getComponentSizes() avoids distinct() overhead. | âœ… **OPTIMIZED** - Part 1 improved from O(nÂ² log n) to O(nÂ² log k), ~19% faster execution |
| Day9 | [`MaxRectangleArea.java`](../../2025/src/main/java/info/jab/aoc2025/day9/MaxRectangleArea.java) | O(nÂ²) | O(nÂ³) âœ… | 0.142s | Part 1: Generates all point pairs (n choose 2 â‰ˆ nÂ²), calculates area for each pair O(1), finds maximum. Part 2: **OPTIMIZED** - Generates all point pairs O(nÂ²), pre-computes vertical edges O(n), uses parallel streams for validation. For each pair validates rectangle inside polygon by checking all edges O(n) - optimized point-in-polygon check and edge intersection check with quick bounds filtering. | âœ… **OPTIMIZED**: Part 1 must examine all pairs to find maximum area. Part 2 optimized with: (1) pre-computed vertical edges for faster ray casting, (2) parallel processing for independent pair validations, (3) quick bounds filtering before expensive intersection checks, (4) combined point-in-polygon checks. Big O remains O(nÂ³) but constant factors significantly reduced (~7.4x faster in practice). | âœ… **OPTIMIZED** - Optimal Big O complexity with significantly improved constant factors |
| Day10 | [`ButtonPressOptimizer.java`](../../2025/src/main/java/info/jab/aoc2025/day10/ButtonPressOptimizer.java) | O(LÃ—2^(n/2)) | O(LÃ—(RÃ—CÂ² + k^f)) âœ… | 0.352s | Part 1: **OPTIMIZED** - Meet-in-the-middle ($O(2^{n/2})$) using primitive maps and Gray Code bit manipulation for O(1) state updates. Part 2: **OPTIMIZED** - Uses RREF (Reduced Row Echelon Form) O(RÃ—CÂ²) to reduce system to free variables, then parallel backtracking O(k^f) where f << n. Zero allocations in search loop, precomputed coefficient matrices, and dynamic bounds pruning. | âœ… **OPTIMIZED**: Part 1 uses optimal MitM with Gray Code updates. Part 2 uses RREF to reduce search space from k^n to k^f (f = free variables, typically f << n). Parallel ForkJoinPool execution with thread-safe atomic updates. Execution time improved from ~11.32s to ~0.352s (~32x faster). | âœ… **OK** - Optimal solution using RREF + backtracking |

## Legend

### Variable Definitions

- **n**: Number of rotations/operations (for Day1), line length (for Day3), or number of points (for Day8, Day9)
- **d**: Average distance per rotation
- **R**: Total number of IDs across all ranges (for Day2), number of rows in grid (for Day4, Day6, Day7), or number of ranges (for Day5)
- **L**: Number of lines/machines (Day10), or total characters (Day3), or average ID length (Day2)
- **n**: Number of buttons (Day10), rotations (Day1), line length (Day3), or points (Day8, Day9)
- **k**: Max presses per button (Day10, default 1000) or cluster size (Day8)
- **R**: Number of rows/targets (Day10 Part 2)
- **C**: Number of columns/buttons (Day10 Part 2)
- **f**: Number of free variables after RREF (Day10 Part 2, typically f << n)
- **r**: Number of ranges
- **C**: Number of columns in grid (for Day4, Day6, Day7)
- **I**: Number of IDs to check (for Day5)

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential complexity that could cause performance issues
  - Significant optimization opportunities

- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved

- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases

- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n)**: Day1 Part 1, Day1 Part 2 âœ…
- **O(RÃ—L)**: Day2 Part 1, Day2 Part 2 âœ…
- **O(L)**: Day3 Part 1, Day3 Part 2 âœ…
- **O(RÃ—C)**: Day4 Part 1 âœ…, Day6 Part 1 âœ…, Day6 Part 2 âœ…, Day7 Part 1 âœ…, Day7 Part 2 âœ…
- **O((RÃ—C)Â²)**: Day4 Part 2 âœ…
- **O(IÃ—R)**: Day5 Part 1 âœ…
- **O(R log R)**: Day5 Part 2 âœ…
- **O(nÂ²)**: Day9 Part 1 âœ…
- **O(nÂ² log k)**: Day8 Part 1 âœ… (where k=1000 << n, optimized from O(nÂ² log n))
- **O(nÂ² log n)**: Day8 Part 2 âœ…
- **O(nÂ³)**: Day9 Part 2 âœ…
- **O(LÃ—2^(n/2))**: Day10 Part 1 âœ… (Meet-in-the-middle with Gray Code)
- **O(LÃ—(RÃ—CÂ² + k^f))**: Day10 Part 2 âœ… (RREF + Parallel Backtracking, where f = free variables, typically f << n)

### Execution Time Analysis (from `./mvnw clean test -pl 2025`)

**Total Build Time:** ~3.0s (estimated, Day 10 optimized from 11.32s to 0.352s)

**Performance Categories:**
- **Very Fast (< 0.05s):** Days 1, 3, 5, 6, 7 (5 days)
- **Fast (0.05-0.2s):** Days 4, 9 (2 days)
- **Moderate (0.2-0.5s):** Days 2, 8, 10 (3 days)
- **Slow (> 0.5s):** None

**Key Observations:**
- Day 10 optimized from 11.32s to 0.352s (~32x faster) using RREF to reduce search space from k^n to k^f, where f (free variables) is typically much smaller than n (total buttons). Parallel execution with ForkJoinPool further improves performance.
- Day 9 optimized from 1.060s to 0.142s (~7.4x faster) with pre-computed vertical edges, parallel processing, and quick bounds filtering
- Day 8 optimized from 0.393s to 0.319s (~19% faster) with priority queue approach for Part 1 and parallel sort for Part 2

### Most Critical Improvements Needed

1. âœ… **Day10 Part 1 & 2**: Optimized.
   - **Part 1**: Implemented Meet-in-the-middle ($O(2^{n/2})$) using Gray Code bit manipulation for O(1) state updates. Pre-sized primitive HashMaps (Eclipse Collections) for efficient lookups.
   - **Part 2**: Uses RREF (Reduced Row Echelon Form) O(RÃ—CÂ²) to transform the system of linear equations, reducing search space from k^n to k^f where f (free variables) << n. Parallel backtracking with ForkJoinPool, zero allocations in search loop, precomputed coefficient matrices, and dynamic bounds pruning using remaining budget.
   - **Status**: Code is now algorithmically optimal. Part 2 complexity reduced from O(LÃ—kâ¿) to O(LÃ—(RÃ—CÂ² + k^f)) where f << n, resulting in ~32x faster execution.

2. âœ… **Day1 Part 2**: Optimized from O(nÃ—d) to O(n) by calculating zero crossings directly using modular arithmetic.
3. âœ… **Day2 Part 2**: Optimized from O(RÃ—LÂ²) to O(RÃ—L) by using direct character comparison instead of substring creation.
4. âœ… **Day8 Part 1**: Optimized from O(nÂ² log n) to O(nÂ² log k) where k=1000 << n, using priority queue approach (~19% faster).
5. âœ… **Day9 Part 2**: Optimized constant factors (~7.4x faster) with pre-computed vertical edges, parallel processing, and quick bounds filtering. Big O remains O(nÂ³) (optimal).

### Performance Notes

- **Day1**: Both parts are now optimal. Part 2 uses modular arithmetic to avoid step-by-step expansion.
- **Day2**: Both parts are now optimal. Part 2 uses efficient character-by-character comparison.
- **Day3**: Both parts are optimal. Uses recursive greedy algorithm with functional programming style.
- **Day4**: Part 1 is optimal O(RÃ—C). Part 2 has quadratic complexity O((RÃ—C)Â²) which is optimal for iterative neighbor-based removal problems where removing cells affects neighbors.
- **Day5**: Part 1 is O(IÃ—R) which is optimal for the straightforward nested iteration approach. Part 2 is O(R log R) which is optimal for range merging (sorting is necessary, merge is linear).
- **Day6**: Both parts are optimal O(RÃ—C). Part 1 processes blocks row by row, Part 2 processes blocks column by column (right to left). Both must examine each cell at least once.
- **Day7**: Both parts are optimal O(RÃ—C). Part 1 tracks beam positions row by row, processing at most O(C) unique positions per row. Part 2 uses memoized recursion to count paths, ensuring each point is computed once.
- **Day8**: Both parts are optimal O(nÂ² log n). Both parts generate all point pairs (n choose 2 â‰ˆ nÂ²) and sort them by distance. Part 1 unions top 1000 shortest connections using DSU. Part 2 unions all connections in order until all points form a single component. The sorting step is necessary to process connections in distance order, and DSU operations are effectively O(1) per operation.
- **Day9**: Part 1 is optimal O(nÂ²) - must examine all point pairs to find maximum area rectangle. Part 2 is optimal O(nÂ³) - generates all point pairs O(nÂ²) and validates each rectangle candidate against all polygon edges O(n) using point-in-polygon and edge intersection checks. **OPTIMIZED** with constant factor improvements: pre-computed vertical edges, parallel processing, and quick bounds filtering reduce execution time by ~7.4x while maintaining optimal Big O complexity.

### Detailed Analysis

#### Day10 - ButtonPressOptimizer

**Part 1 Analysis:**
- **Algorithm**: Meet-in-the-middle (MitM).
- **Approach**: Splits buttons into two halves, generates all XOR combinations for left half O(2^(n/2)), then checks right half combinations O(2^(n/2)) against left half map.
- **Complexity**: $O(L \times 2^{n/2})$ where L = number of lines, n = number of buttons.
- **Optimizations**:
  - Gray Code bit manipulation for O(1) state updates (XOR with single button per iteration).
  - Pre-sized primitive HashMap (Eclipse Collections LongIntHashMap) to avoid resizing.
  - Lazy bit counting only when match found.
- **Space**: O(2^(n/2)) for left half map.

**Part 2 Analysis:**
- **Algorithm**: RREF (Reduced Row Echelon Form) + Parallel Backtracking.
- **Phase 1 - RREF**: Transforms system of linear equations O(RÃ—CÂ²) where R = number of targets, C = number of buttons.
  - Uses Gaussian elimination with rational arithmetic (GCD normalization to prevent overflow).
  - Identifies pivot variables and free variables.
  - Reduces search space from k^n to k^f where f = number of free variables (typically f << n).
- **Phase 2 - Backtracking**: Searches free variable assignments O(k^f) with optimizations:
  - **Zero-Allocation Loop**: Reuses assignment array, no cloning in recursion.
  - **Precomputed Coefficients**: Coefficient matrices precomputed after RREF for O(1) access.
  - **Dynamic Bounds Pruning**: Uses remaining budget to limit search space per free variable.
  - **Parallel Execution**: ForkJoinPool splits first free variable's search space across threads.
  - **Thread-Safe Updates**: AtomicLong for best total with lock-free updates.
- **Complexity**: $O(L \times (R \times C^2 + k^f))$ where f << n, significantly better than naive $O(L \times k^n)$.
- **Optimization**: RREF is the key optimization - reduces exponential base from n (all buttons) to f (free variables only).

**Optimization Implemented:**
âœ… **COMPLETED**:
1. **Part 1**: Meet-in-the-middle with Gray Code bit manipulation for O(1) state updates. Pre-sized primitive HashMaps (Eclipse Collections) for efficient lookups.
2. **Part 2**: RREF-based approach with parallel backtracking:
   - RREF reduces problem from k^n to k^f search space (f << n).
   - Precomputed coefficient matrices for fast pivot calculation.
   - Zero allocations in backtracking loop (reuses assignment array).
   - Parallel ForkJoinPool execution with thread-safe atomic updates.
   - Dynamic bounds pruning using remaining budget.
- Execution time improved from ~11.32s to ~0.352s (~32x faster) with RREF optimization.

#### Day1 - DialRotator
...
