# Big O Notation Analysis - Advent of Code 2024

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2024 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements | Requires Attention |
|-----|------|-------------|--------------|-------|--------------|-------------------|
| Day1 | `HistorianHysteria.java` | O(n log n) | O(nÂ²) | Part 1: Sorting two lists (O(n log n)) + linear scan (O(n)). Part 2: For each element in listLeft, count occurrences in listRight (O(n) per element). | Part 2: Use HashMap to count occurrences in O(n) time, reducing to O(n log n) overall. | ðŸŸ¡ MEDIUM - Part 2 can be optimized from O(nÂ²) to O(n log n) |
| Day2 | `SafeReports2.java` | O(n) | O(nÂ²) | Part 1: Single pass validation. Part 2: Generates all sublists by removing one element (O(n) per report), then validates each (O(n)). | Part 2: Early termination when valid sublist found could improve average case. Consider memoization for repeated validations. | ðŸŸ¢ LOW - Part 2 quadratic but acceptable for typical input sizes |
| Day3 | `MullItOver2.java` | O(n) | O(n) | Linear scan with regex matching. Part 2 uses accumulator pattern with Gatherers.fold. | Already optimal for linear input. Consider pre-compiling regex patterns if reused. | âœ… OK - Already optimal |
| Day4 | `SoupLetter2.java` | O(RÃ—CÃ—L) | O(RÃ—CÃ—L) | Grid search: for each cell (RÃ—C), check 8 directions up to word length L. Recursive word matching. | Could optimize by skipping cells that don't match first letter. Early termination in recursive calls. | ðŸŸ¢ LOW - Minor optimization opportunity |
| Day5 | `PrintQueue2.java` | O(nÃ—m) | O(nÃ—mÂ²) | Part 1: Validate each update against rules. Part 2: Custom sort with nested comparisons. | Part 2: Use topological sort (O(V+E)) instead of custom comparator. Build dependency graph once. | ðŸŸ¡ MEDIUM - Part 2 can be optimized with topological sort |
| Day6 | `Game.java` | O(RÃ—C) | N/A | BFS-like traversal until guardian exits grid. Visits each cell at most once. | Part 2 not implemented. Consider cycle detection for infinite loops. Use visited set with direction state. | ðŸ”´ HIGH - Part 2 not implemented |
| Day7 | `BridgeRepair.java` | O(2^n) | O(3^n) | Recursive backtracking: try all operator combinations. Part 2 adds concatenation operator. | Use memoization with (position, current_value) as key. Consider iterative DP if possible. | ðŸ”´ HIGH - Exponential complexity, needs memoization/DP |
| Day8 | `AntennaMap.java` | O(kÂ²) | O(kÂ²Ã—d) | k = number of antennas. Part 1: Cartesian product of antenna pairs. Part 2: Generates harmonics along lines (d = distance). | Could optimize by grouping antennas by type first. Use geometric properties to reduce pair checks. | ðŸŸ¢ LOW - Quadratic acceptable for typical antenna counts |
| Day9 | `DiskCompactor.java` | O(nÂ²) | O(nÂ²) | Part 1: Nested loops for compaction. Part 2: Iterates files and searches for gaps. | Part 2: Use priority queue for gaps (sorted by position) to find first fit in O(log n). Overall O(n log n). | ðŸŸ¡ MEDIUM - Part 2 can be optimized from O(nÂ²) to O(n log n) |
| Day10 | `LavaHikingTrails2.java` | O(RÃ—C) | O(RÃ—CÃ—paths) | BFS from each trailhead (0). Part 2 counts all distinct paths, potentially exponential. | Part 2: Use DFS with memoization to count paths. Memoize (position, height) -> path count. | ðŸŸ¡ MEDIUM - Part 2 path counting needs memoization |
| Day11 | `PlutonianPebbles.java` | O(nÃ—b) | O(nÃ—b) | n = initial stones, b = blinks. Part 1: Naive simulation (exponential growth). Part 2: Memoized recursion (optimal). | Part 1: Already has memoization in Part 2. Refactor Part 1 to use same memoized approach. | ðŸŸ¢ LOW - Part 1 should use Part 2's memoized approach |
| Day12 | `GardenGroups.java` | O(RÃ—C) | O(RÃ—C) | DFS/Stack-based region exploration. Each cell visited once. Part 2 calculates sides differently. | Already optimal. Consider using Union-Find for region grouping if needed for multiple queries. | âœ… OK - Already optimal |
| Day13 | `ClawContraption.java` | O(n) | O(n) | Linear scan through claw machines. Each machine solved independently with simple arithmetic. | Already optimal. No improvements needed for linear complexity. | âœ… OK - Already optimal |
| Day14 | `RobotMotion.java` | O(RÃ—C) | O(TÃ—RÃ—C) | Part 1: Single time step simulation. Part 2: Brute force search up to TIME_LIMIT (10000). | Part 2: Use cycle detection. Robot positions repeat after LCM of width/height. Reduce to O(RÃ—C). | ðŸŸ¡ MEDIUM - Part 2 brute force needs cycle detection |
| Day15 | `WarehouseScaled.java` | O(MÃ—RÃ—C) | O(MÃ—RÃ—C) | M = moves, RÃ—C = grid size. Each move may scan entire row/column for boxes. | Optimize box movement: maintain box positions in data structure (Set/Map) for O(1) lookup. Reduce to O(MÃ—max_boxes). | ðŸŸ¢ LOW - Can optimize box position tracking |
| Day16 | `ReindeerMaze.java` | O(V log V) | O(V log V) | A* / Dijkstra on state space (position + direction). V = vertices in state graph. | Already using priority queue. Consider bidirectional search or A* with better heuristic. | âœ… OK - Well optimized |
| Day16 | `ReindeerMaze2.java` | O(V log V) | O(V log V) | Similar to Part 1 but tracks all best paths. Visited set prevents revisiting same state. | Consider using bit masks for visited states if state space is small. | âœ… OK - Well optimized |
| Day17 | `ChronospatialComputer.java` | O(n) | N/A | Linear execution of opcodes. Simple virtual machine. | Already optimal. No improvements needed. | âœ… OK - Already optimal |
| Day17 | `ChronospatialComputer2.java` | O(n) | O(2^n) | Part 2: Backtracking to find register A value. Exponential search space. | Use constraint propagation or SAT solver. Analyze opcode patterns to reduce search space. | ðŸ”´ HIGH - Part 2 exponential backtracking needs optimization |
| Day18 | `RamRun.java` | O(V+E) | O(kÃ—(V+E)) | BFS for pathfinding. Part 2: Iterates k times (corrupted coordinates) running BFS each time. | Part 2: Use incremental BFS or maintain reachability data structure. Consider binary search on k. | ðŸŸ¢ LOW - Part 2 can be optimized with incremental approach |
| Day19 | `TowelArrangement.java` | O(nÃ—mÃ—L) | O(nÃ—mÃ—L) | DP: n = designs, m = patterns, L = design length. Part 2 counts ways instead of boolean. | Already optimal DP solution. Consider preprocessing patterns into trie for faster matching. | âœ… OK - Already optimal DP |
| Day20 | `RaceCondition.java` | O(VÂ² log V) | O(VÂ² log V) | Dijkstra for pathfinding + nested loops for cheat detection. Checks all pairs on path. | Optimize cheat detection: use spatial data structures (KD-tree) for distance queries. Reduce to O(V log V). | ðŸŸ¡ MEDIUM - Quadratic cheat detection can be optimized |
| Day21 | `KeypadConundrum2.java` | O(exp(d)) | O(exp(d)) | Recursive backtracking with memoization. d = depth of keypad nesting. Exponential in worst case. | Memoization already implemented. Consider iterative BFS for shortest path calculation. Analyze keypad structure for optimizations. | ðŸ”´ HIGH - Exponential complexity despite memoization |
| Day22 | `MonkeyMarket.java` | O(nÃ—i) | O(nÃ—iÃ—s) | n = secrets, i = iterations (2000), s = sequence length. Part 2 tracks 4-element sequences. | Part 2: Use rolling hash for sequence detection. Reduce sequence tracking overhead. Consider bit manipulation optimizations. | ðŸŸ¢ LOW - Minor optimization opportunity |
| Day23 | `LanParty.java` | O(VÂ³) | O(3^(V/3)) | Part 1: Triangle finding (nested loops). Part 2: Bron-Kerbosch for maximal cliques (exponential worst case). | Part 1: Use adjacency list optimization. Part 2: Bron-Kerbosch is optimal for clique finding, but consider pivot optimization variant. | ðŸŸ¢ LOW - Part 1 can be optimized, Part 2 is optimal algorithm |
| Day24 | `CrossedWires.java` | O(GÃ—I) | N/A | G = gates, I = iterations until all resolved. Worst case O(GÂ²) if gates resolve one per iteration. | Use topological sort to process gates in dependency order. Reduce to O(G). | ðŸŸ¡ MEDIUM - Can use topological sort for better complexity |
| Day24 | `CrossedWires2.java` | O(GÂ²) | O(GÂ²) | Nested loops checking gate relationships. Part 2: Validates gate correctness. | Optimize with adjacency lists or dependency graphs. Preprocess gate relationships once. | ðŸŸ¡ MEDIUM - Can optimize with dependency graph preprocessing |
| Day25 | `LockKeyMatcher.java` | O(LÃ—KÃ—W) | N/A | L = locks, K = keys, W = width. Nested loops comparing all lock-key pairs. | Use early termination in fits() check. Consider sorting keys/locks by height patterns for faster rejection. | ðŸ”´ HIGH - Part 2 not implemented |

## Legend

### Variable Definitions

- **n**: Number of input elements/lines
- **R**: Number of rows in grid
- **C**: Number of columns in grid
- **V**: Number of vertices/nodes in graph
- **E**: Number of edges in graph
- **L**: Length of string/word
- **M**: Number of moves/commands
- **k**: Number of antennas/items
- **b**: Number of blinks/iterations
- **T**: Time steps
- **G**: Number of gates
- **i**: Iterations
- **s**: Sequence length
- **W**: Width of schematic

### Attention Level Indicators

- **ðŸ”´ HIGH**: Critical issues requiring immediate attention
  - Missing Part 2 implementation
  - Exponential complexity that could cause performance issues
  - Significant optimization opportunities
  
- **ðŸŸ¡ MEDIUM**: Should be addressed for better performance
  - Quadratic complexity that can be optimized
  - Missing optimizations that would improve scalability
  - Brute force approaches that can be improved
  
- **ðŸŸ¢ LOW**: Minor improvements possible
  - Small optimizations that may not be critical
  - Code refactoring opportunities
  - Performance improvements for edge cases
  
- **âœ… OK**: No issues or already optimal
  - Well-optimized solutions
  - Appropriate complexity for the problem
  - No significant improvements needed

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 3, 11, 13, 17 (Part 1)
- **O(RÃ—C) or O(V+E)**: Days 6, 10, 12, 16, 18 (Part 1)
- **O(nÂ²) or O(VÂ²)**: Days 1 (Part 2), 2 (Part 2), 5, 8, 9, 20, 24
- **O(exp) or O(2^n)**: Days 7, 17 (Part 2), 21

### Most Critical Improvements Needed

1. **Day7 (BridgeRepair)**: Exponential complexity - needs memoization
2. **Day17 Part 2**: Exponential backtracking - consider constraint solving
3. **Day21**: Exponential recursion - already has memoization but could benefit from iterative approach
4. **Day14 Part 2**: Brute force - implement cycle detection
5. **Day20**: Quadratic cheat detection - use spatial data structures
6. **Day5 Part 2**: Custom sort - use topological sort
7. **Day9 Part 2**: Nested loops - use priority queue for gaps

### Performance Notes

- Most grid-based problems (Days 4, 6, 8, 10, 12, 15, 16, 18, 20) are already well-optimized with BFS/DFS
- Dynamic programming solutions (Day 19) are optimal
- Several days have exponential worst-case complexity but perform well in practice due to:
  - Early termination
  - Memoization
  - Small input sizes
  - Problem-specific optimizations

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Focus optimizations** on days with exponential complexity first
3. **Consider algorithmic improvements** before micro-optimizations
4. **Use appropriate data structures** (priority queues, hash maps, spatial indexes) where applicable
5. **Implement memoization** for recursive solutions with overlapping subproblems
