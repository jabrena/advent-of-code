# Big O Notation Analysis - Advent of Code 2024

This document provides a comprehensive analysis of the time complexity (Big O notation) for all days in the 2024 module.

## Analysis Table

| Day | File | Part 1 Big O | Part 2 Big O | Notes | Improvements |
|-----|------|-------------|--------------|-------|--------------|
| Day1 | `HistorianHysteria.java` | O(n log n) | O(n²) | Part 1: Sorting two lists (O(n log n)) + linear scan (O(n)). Part 2: For each element in listLeft, count occurrences in listRight (O(n) per element). | Part 2: Use HashMap to count occurrences in O(n) time, reducing to O(n log n) overall. |
| Day2 | `SafeReports2.java` | O(n) | O(n²) | Part 1: Single pass validation. Part 2: Generates all sublists by removing one element (O(n) per report), then validates each (O(n)). | Part 2: Early termination when valid sublist found could improve average case. Consider memoization for repeated validations. |
| Day3 | `MullItOver2.java` | O(n) | O(n) | Linear scan with regex matching. Part 2 uses accumulator pattern with Gatherers.fold. | Already optimal for linear input. Consider pre-compiling regex patterns if reused. |
| Day4 | `SoupLetter2.java` | O(R×C×L) | O(R×C×L) | Grid search: for each cell (R×C), check 8 directions up to word length L. Recursive word matching. | Could optimize by skipping cells that don't match first letter. Early termination in recursive calls. |
| Day5 | `PrintQueue2.java` | O(n×m) | O(n×m²) | Part 1: Validate each update against rules. Part 2: Custom sort with nested comparisons. | Part 2: Use topological sort (O(V+E)) instead of custom comparator. Build dependency graph once. |
| Day6 | `Game.java` | O(R×C) | N/A | BFS-like traversal until guardian exits grid. Visits each cell at most once. | Part 2 not implemented. Consider cycle detection for infinite loops. Use visited set with direction state. |
| Day7 | `BridgeRepair.java` | O(2^n) | O(3^n) | Recursive backtracking: try all operator combinations. Part 2 adds concatenation operator. | Use memoization with (position, current_value) as key. Consider iterative DP if possible. |
| Day8 | `AntennaMap.java` | O(k²) | O(k²×d) | k = number of antennas. Part 1: Cartesian product of antenna pairs. Part 2: Generates harmonics along lines (d = distance). | Could optimize by grouping antennas by type first. Use geometric properties to reduce pair checks. |
| Day9 | `DiskCompactor.java` | O(n²) | O(n²) | Part 1: Nested loops for compaction. Part 2: Iterates files and searches for gaps. | Part 2: Use priority queue for gaps (sorted by position) to find first fit in O(log n). Overall O(n log n). |
| Day10 | `LavaHikingTrails2.java` | O(R×C) | O(R×C×paths) | BFS from each trailhead (0). Part 2 counts all distinct paths, potentially exponential. | Part 2: Use DFS with memoization to count paths. Memoize (position, height) -> path count. |
| Day11 | `PlutonianPebbles.java` | O(n×b) | O(n×b) | n = initial stones, b = blinks. Part 1: Naive simulation (exponential growth). Part 2: Memoized recursion (optimal). | Part 1: Already has memoization in Part 2. Refactor Part 1 to use same memoized approach. |
| Day12 | `GardenGroups.java` | O(R×C) | O(R×C) | DFS/Stack-based region exploration. Each cell visited once. Part 2 calculates sides differently. | Already optimal. Consider using Union-Find for region grouping if needed for multiple queries. |
| Day13 | `ClawContraption.java` | O(n) | O(n) | Linear scan through claw machines. Each machine solved independently with simple arithmetic. | Already optimal. No improvements needed for linear complexity. |
| Day14 | `RobotMotion.java` | O(R×C) | O(T×R×C) | Part 1: Single time step simulation. Part 2: Brute force search up to TIME_LIMIT (10000). | Part 2: Use cycle detection. Robot positions repeat after LCM of width/height. Reduce to O(R×C). |
| Day15 | `WarehouseScaled.java` | O(M×R×C) | O(M×R×C) | M = moves, R×C = grid size. Each move may scan entire row/column for boxes. | Optimize box movement: maintain box positions in data structure (Set/Map) for O(1) lookup. Reduce to O(M×max_boxes). |
| Day16 | `ReindeerMaze.java` | O(V log V) | O(V log V) | A* / Dijkstra on state space (position + direction). V = vertices in state graph. | Already using priority queue. Consider bidirectional search or A* with better heuristic. |
| Day16 | `ReindeerMaze2.java` | O(V log V) | O(V log V) | Similar to Part 1 but tracks all best paths. Visited set prevents revisiting same state. | Consider using bit masks for visited states if state space is small. |
| Day17 | `ChronospatialComputer.java` | O(n) | N/A | Linear execution of opcodes. Simple virtual machine. | Already optimal. No improvements needed. |
| Day17 | `ChronospatialComputer2.java` | O(n) | O(2^n) | Part 2: Backtracking to find register A value. Exponential search space. | Use constraint propagation or SAT solver. Analyze opcode patterns to reduce search space. |
| Day18 | `RamRun.java` | O(V+E) | O(k×(V+E)) | BFS for pathfinding. Part 2: Iterates k times (corrupted coordinates) running BFS each time. | Part 2: Use incremental BFS or maintain reachability data structure. Consider binary search on k. |
| Day19 | `TowelArrangement.java` | O(n×m×L) | O(n×m×L) | DP: n = designs, m = patterns, L = design length. Part 2 counts ways instead of boolean. | Already optimal DP solution. Consider preprocessing patterns into trie for faster matching. |
| Day20 | `RaceCondition.java` | O(V² log V) | O(V² log V) | Dijkstra for pathfinding + nested loops for cheat detection. Checks all pairs on path. | Optimize cheat detection: use spatial data structures (KD-tree) for distance queries. Reduce to O(V log V). |
| Day21 | `KeypadConundrum2.java` | O(exp(d)) | O(exp(d)) | Recursive backtracking with memoization. d = depth of keypad nesting. Exponential in worst case. | Memoization already implemented. Consider iterative BFS for shortest path calculation. Analyze keypad structure for optimizations. |
| Day22 | `MonkeyMarket.java` | O(n×i) | O(n×i×s) | n = secrets, i = iterations (2000), s = sequence length. Part 2 tracks 4-element sequences. | Part 2: Use rolling hash for sequence detection. Reduce sequence tracking overhead. Consider bit manipulation optimizations. |
| Day23 | `LanParty.java` | O(V³) | O(3^(V/3)) | Part 1: Triangle finding (nested loops). Part 2: Bron-Kerbosch for maximal cliques (exponential worst case). | Part 1: Use adjacency list optimization. Part 2: Bron-Kerbosch is optimal for clique finding, but consider pivot optimization variant. |
| Day24 | `CrossedWires.java` | O(G×I) | N/A | G = gates, I = iterations until all resolved. Worst case O(G²) if gates resolve one per iteration. | Use topological sort to process gates in dependency order. Reduce to O(G). |
| Day24 | `CrossedWires2.java` | O(G²) | O(G²) | Nested loops checking gate relationships. Part 2: Validates gate correctness. | Optimize with adjacency lists or dependency graphs. Preprocess gate relationships once. |
| Day25 | `LockKeyMatcher.java` | O(L×K×W) | N/A | L = locks, K = keys, W = width. Nested loops comparing all lock-key pairs. | Use early termination in fits() check. Consider sorting keys/locks by height patterns for faster rejection. |

## Legend

- **n**: Number of input elements/lines
- **R**: Number of rows in grid
- **C**: Number of columns in grid
- **V**: Number of vertices/nodes in graph
- **E**: Number of edges in graph
- **L**: Length of string/word
- **M**: Number of moves/commands
- **k**: Number of antennas/items
- **b**: Number of blinks/iterations
- **T**: Time steps
- **G**: Number of gates
- **i**: Iterations
- **s**: Sequence length
- **W**: Width of schematic

## Summary

### Complexity Distribution

- **O(n) or O(n log n)**: Days 1, 3, 11, 13, 17 (Part 1)
- **O(R×C) or O(V+E)**: Days 6, 10, 12, 16, 18 (Part 1)
- **O(n²) or O(V²)**: Days 1 (Part 2), 2 (Part 2), 5, 8, 9, 20, 24
- **O(exp) or O(2^n)**: Days 7, 17 (Part 2), 21

### Most Critical Improvements Needed

1. **Day7 (BridgeRepair)**: Exponential complexity - needs memoization
2. **Day17 Part 2**: Exponential backtracking - consider constraint solving
3. **Day21**: Exponential recursion - already has memoization but could benefit from iterative approach
4. **Day14 Part 2**: Brute force - implement cycle detection
5. **Day20**: Quadratic cheat detection - use spatial data structures
6. **Day5 Part 2**: Custom sort - use topological sort
7. **Day9 Part 2**: Nested loops - use priority queue for gaps

### Performance Notes

- Most grid-based problems (Days 4, 6, 8, 10, 12, 15, 16, 18, 20) are already well-optimized with BFS/DFS
- Dynamic programming solutions (Day 19) are optimal
- Several days have exponential worst-case complexity but perform well in practice due to:
  - Early termination
  - Memoization
  - Small input sizes
  - Problem-specific optimizations

## Recommendations

1. **Profile actual execution times** using `./mvnw clean test surefire-report:report-only` to identify bottlenecks
2. **Focus optimizations** on days with exponential complexity first
3. **Consider algorithmic improvements** before micro-optimizations
4. **Use appropriate data structures** (priority queues, hash maps, spatial indexes) where applicable
5. **Implement memoization** for recursive solutions with overlapping subproblems
